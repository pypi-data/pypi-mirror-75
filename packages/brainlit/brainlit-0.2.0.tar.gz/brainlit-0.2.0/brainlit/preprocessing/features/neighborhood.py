import numpy as np
import brainlit
from brainlit.preprocessing import preprocess, image_process
from scipy import ndimage as ndi
from pathlib import Path
import pandas as pd
from itertools import product

from .base import BaseFeatures


class NeighborhoodFeatures(BaseFeatures):
    """
    Computes features based off neighborhood properties.
    """

    def __init__(self, url, size=[1, 1, 1], offset=[15, 15, 15], segment_url=None):
        super().__init__(url=url, size=size, offset=offset, segment_url=segment_url)

    def _convert_to_features(self, img, include_neighborhood=None):
        """
        Computes features from image data by flattening the image.

        Parameters
        ----------
        img : ndarray
            Image data.

        include_neighborhood : boolean
            Argument is ignored.

        Returns
        -------
        features : dict
            Feature data generated by flattening the image.
        """
        return dict(enumerate(img.flatten()))


def subsample(arr, orig_shape, dest_shape):
    """
    Subsamples a flattened neighborhood to a smaller flattened neighborhood.
    ----------
    arr : np.ndarray
        The flattened array
    orig_shape : tuple
        The original shape of the array before flattening
    dest_shape : tuple
        The desired shape of the array before flattening
    """
    start = np.subtract(orig_shape, dest_shape) // 2
    end = start + dest_shape
    if len(orig_shape) is 2:
        idx = np.ravel_multi_index(
            (np.mgrid[start[0] : end[0], start[1] : end[1]].reshape(2, -1)), orig_shape
        )
    elif len(orig_shape) is 3:
        idx = np.ravel_multi_index(
            (
                np.mgrid[
                    start[0] : end[0], start[1] : end[1], start[2] : end[2]
                ].reshape(3, -1)
            ),
            orig_shape,
        )
    return arr[idx]
