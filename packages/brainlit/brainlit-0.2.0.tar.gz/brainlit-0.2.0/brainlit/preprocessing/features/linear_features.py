import numpy as np
import brainlit
from brainlit.preprocessing import preprocess, image_process
from scipy import ndimage as ndi
from pathlib import Path
import pandas as pd
from itertools import product

from .base import BaseFeatures


class LinearFeatures(BaseFeatures):
    """
    Computes features based off linear filters.
    """

    def __init__(self, url, size=[1, 1, 1], offset=[15, 15, 15], segment_url=None):
        super().__init__(url=url, size=size, offset=offset, segment_url=segment_url)
        self.filters = []

    def add_filter(
        self,
        name="gaussian",
        sigma=[1, 1, 0.3],
        mode="reflect",
        cval=0,
        truncate=4,
        phi=[0, 0],
        frequency=1,
        offset=0,
    ):
        """
        Adds filter to class for feature computation

        Parameters
        ----------
        name : str
            Name of filter to add. Currently supports `gaussian`, `gaussian gradient`,
            `gaussian laplace`, and `gabor`.
        
        sigma : scalar or sequence of scalars
            Standard deviation for Gaussian kernel. The standard
            deviations of the Gaussian filter are given for each axis as a
            sequence, or as a single number, in which case it is equal for
            all axes.

        mode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional
            The mode parameter determines how the input array is extended beyond its boundaries. 
            Default is ‘reflect’.

        cval : scalar, optional
            Value to fill past edges of input if mode is ‘constant’. Default is 0.0.

        truncate : float
            Truncate the filter at this many standard deviations.
            Default is 4.0. 

        phi : scalar or sequence of scalars
            Angles specifying orientation of the periodic complex
            exponential. If the input is n-dimensional, then phi
            is a sequence of length n-1. Convention follows
            https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates.
        
        frequency : scalar
            Frequency of the complex exponential. Units are revolutions/voxels. 

        offset : scalar
            Phase shift of the complex exponential. Units are radians.
        """
        if name == "gaussian":
            self.filters.append(
                (name, {"sigma": sigma, "mode": mode, "cval": 0, "truncate": truncate})
            )
        elif name == "gaussian gradient":
            self.filters.append(
                (name, {"sigma": sigma, "mode": mode, "cval": 0, "truncate": truncate})
            )
        elif name == "gaussian laplace":
            self.filters.append(
                (name, {"sigma": sigma, "mode": mode, "cval": 0, "truncate": truncate})
            )
        elif name == "gabor":
            self.filters.append(
                (
                    name,
                    {
                        "sigma": sigma,
                        "phi": phi,
                        "frequency": frequency,
                        "offset": offset,
                        "cval": 0,
                        "truncate": truncate,
                    },
                )
            )
        else:
            raise ValueError("Invalid filter name")

    def _convert_to_features(self, img, include_neighborhood):
        """
        Computes features from image data by applying linear filters.

        Parameters
        ----------
        img : ndarray
            Image data.
        
        include_neighborhood : boolean
            If True, the neighborhood itself is also included with the
            feature responses.

        Returns
        -------
        features : ndarray
            Feature data generated by applying linear filters.
        """
        voxel = (np.subtract(img.shape, 1) / 2).astype(int)

        if include_neighborhood:
            filter_response = dict(enumerate(img.flatten()))
            filter_count = len(img.flatten())
        else:
            filter_response = {}
            filter_count = 0

        for filter in self.filters:
            parameters = filter[1]
            parameters["input"] = img
            if filter[0] == "gaussian":
                g_temp = ndi.gaussian_filter(**parameters)
                filter_response[filter_count] = float(
                    g_temp[[voxel[0]], [voxel[1]], [voxel[2]]]
                )
            elif filter[0] == "gaussian gradient":
                gg_temp = ndi.gaussian_gradient_magnitude(**parameters)
                filter_response[filter_count] = float(
                    gg_temp[[voxel[0]], [voxel[1]], [voxel[2]]]
                )
            elif filter[0] == "gaussian laplace":
                gl_temp = ndi.gaussian_laplace(**parameters)
                filter_response[filter_count] = float(
                    gl_temp[[voxel[0]], [voxel[1]], [voxel[2]]]
                )
            elif filter[0] == "gabor":
                gb_temp = image_process.gabor_filter(**parameters)
                gb_temp = gb_temp[0]
                filter_response[filter_count] = float(
                    gb_temp[[voxel[0]], [voxel[1]], [voxel[2]]]
                )
            filter_count += 1
        return filter_response
