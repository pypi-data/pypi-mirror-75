#
# Copyright (c) 2016-2019 Deephaven Data Labs and Patent Pending
#

import jpy
import jpyutil
import os
from glob import glob
import re
import logging
import warnings

from deephaven import initialize
from .conversion_utils import _isStr


def start_jvm(devroot=None,
              workspace=None,
              propfile=None,
              keyfile=None,
              verbose=False,
              skip_default_classpath=None,
              # The following are the jpyutil.init_jvm options which are passed through after attaching our options
              java_home=None,
              jvm_dll=None,
              jvm_maxmem=None,
              jvm_classpath=None,
              jvm_properties=None,
              jvm_options=None,
              config_file=None,
              config=None):
    """
    Starts a JVM within this Python process to interface with Iris.

    This is a small convenience wrapper around :func:`jpyutil.init_jvm`. Additionally, the Configuration is loaded
    and and Iris classes are brought into Python.

    :param devroot: the devroot parameter for Iris. Defaults to the ``ILLUMON_DEVROOT`` environment variable, or
      ``/usr/illumon/latest``
    :param workspace: the workspace parameter for Iris. Defaults to the ``ILLUMON_WORKSPACE`` environment variable
    :param propfile: the ``Configuration.rootFile`` parameter for Iris. Defaults to the ``ILLUMON_PROPFILE`` environment
      variable
    :param keyfile: your private key file for authenticating to Iris
    :param skip_default_classpath: if True, do not attempt to compute default java classpath
    :param verbose: if True, print out the classpath and properties we have constructed

    The rest of the parameters are passed through to :func:`jpyutil.init_jvm`. The values for `jvm_classpath` and
    `jvm_properties` may have been modified based on the values of other arguments.

    :param java_home:
    :param jvm_dll:
    :param jvm_maxmem:
    :param jvm_classpath: optional initial classpath elements. Default elements will be appended unless
      `skip_default_classpath` is specified
    :param jvm_properties: inserted into the dictionary generated by `devroot`, `workspace`, `propfile`, and `keyfile`.
    :param jvm_options:
    :param config_file:
    :param config:
    """

    # setup defaults

    for stem in ['DEEPHAVEN', 'ILLUMON']:
        if devroot is None:
            devroot = os.environ.get("{}_DEVROOT".format(stem), None)
        if workspace is None:
            workspace = os.environ.get("{}_WORKSPACE".format(stem), None)
        if propfile is None:
            propfile = os.environ.get("{}_PROPFILE".format(stem), None)

    # validate devroot & workspace
    if devroot is None:
        raise IOError("idb.init: devroot is not specified.")
    if not os.path.isdir(devroot):
        raise IOError("idb.init: devroot={} does not exist.".format(devroot))

    if workspace is None:
        raise IOError("idb.init: workspace is not specified.")
    if not os.path.isdir(workspace):
        raise IOError("idb.init: workspace={} does not exist.".format(workspace))

    dtemp = workspace
    for entry in ['', 'cache', 'classes']:
        dtemp = os.path.join(dtemp, entry)
        if os.path.exists(dtemp):
            if not (os.path.isdir(dtemp) and os.access(dtemp, os.W_OK | os.X_OK)):
                # this is silly, but a directory must be both writable and executible by a user for a
                # file to be written there - write without executible is delete only
                raise IOError("idb.init: workspace directory={} does exists, but is "
                              "not writeable by your user.".format(dtemp))
        else:
            # Log potentially helpful warning - in case of failure.
            warnings.warn("idb.init: workspace directory={} does not exist, and its absence may "
                          "lead to an error. When required, it SHOULD get created with appropriate "
                          "permissions by the iris class DynamicCompileUtils. If strange errors arise "
                          "from jpy about inability to find some java class, then check "
                          "the existence/permissions of the directory.".format(dtemp),
                          RuntimeWarning)

    # setup environment
    jProperties = {'devroot': devroot, 'workspace': workspace}
    if propfile is not None:
        jProperties['Configuration.rootFile'] = propfile
    if keyfile is not None:
        jProperties['WAuthenticationClientManager.defaultPrivateKeyFile'] = keyfile
    if jvm_properties is not None:
        jProperties.update(jvm_properties)

    jClassPath = []
    # allow for string or array, because users get confused
    if jvm_classpath is not None:
        if _isStr(jvm_classpath):
            jClassPath.extend(jvm_classpath.split(os.path.pathsep))
        elif isinstance(jvm_classpath, list):
            jClassPath.extend(jvm_classpath)
        else:
            raise ValueError("Invalid jvm_classpath type = {}. list or string accepted.".format(type(jvm_classpath)))

    defaultClasspath = None
    if not skip_default_classpath:
        defaultClasspath = getDefaultClasspath(devroot, workspace)
        jClassPath.extend(defaultClasspath)

    jClassPath = expandWildcardsInList(jClassPath)

    if verbose:
        print("JVM default classpath...{}".format(defaultClasspath))
        print("JVM classpath...{}".format(jClassPath))
        print("JVM properties...{}".format(jProperties))

    jpy.VerboseExceptions.enabled = True
    jpyutil.init_jvm(
        java_home=java_home,
        jvm_dll=jvm_dll,
        jvm_maxmem=jvm_maxmem,
        jvm_classpath=jClassPath,
        jvm_properties=jProperties,
        jvm_options=jvm_options,
        config_file=config_file,
        config=config)
    # Loads our configuration and initializes the class types
    initialize()


def getDefaultClasspath(devroot, workspace):
    """
    Determines whether running as client or server, and returns default classpath elements accordingly.

    :param devroot: the devroot parameter for Iris; will be set by the time this is called
    :param workspace: the workspace parameter for Iris; will be set by the time this is called
    :return: the default classpath as an array of strings
    """

    # first determine whether this is client or server
    # clients have devroot/getdown.txt
    # servers have /usr/illumon/latest
    # if neither seems to apply, fail

    isclient = None
    if os.path.isfile(os.path.join(devroot, "getdown.txt")):
        isclient = True
    else:
        if os.path.isdir("/usr/illumon/latest"):
            isclient = False
        else:
            raise IOError("Could not decide how to create classpath. Neither /usr/illumon/latest nor "
                          "<devroot>/getdown.txt exist")

    if isclient:
        # this construction should match the classpath specified in getdown.txt
        return flatten([os.path.join(devroot, el) for el in ["private_classes", "private_jars/*", "override",
                                                             "resources", "hotfixes/*", "java_lib/*"]])
    else:  # is server
        # this construction should match the classpath specified in launch and launch_functions
        return flatten(["{}/etc".format(workspace),
                        "/etc/sysconfig/illumon.d/override",
                        "/etc/sysconfig/illumon.d/resources",
                        "/etc/sysconfig/illumon.d/java_lib/*",
                        "/etc/sysconfig/illumon.d/hotfixes/*",
                        addPluginClasspaths(),
                        "{}/etc".format(devroot),
                        "{}/java_lib/*".format(devroot)])


def addPluginClasspaths():
    """
    Helper method. Adds elements to classpath listing.

    :return: classpath fragment
    """

    new_list = []
    addGlobal(new_list, "/etc/sysconfig/illumon.d/plugins")
    addGlobal(new_list, "/etc/illumon/plugins")
    return new_list


def addGlobal(new_list, base):
    """
    Helper method. Add elements to classpath listing.

    :param new_list: current classpath list
    :param base: base directory
    """

    if not os.path.isdir(base):
        return
    for plugin in os.listdir(base):
        thedir = os.path.join(base, plugin, "global")
        if os.path.isdir(thedir):
            new_list.extend([os.path.join(thedir, dependency) for dependency in os.listdir(thedir)])


def expandWildcardsInList(elements):
    """
    Takes list of strings, possibly containing wildcard characters, and returns the corresponding full list. This is
    intended for appropriately expanding classpath entries.

    :param elements: list of strings (paths)
    :return: corresponding list of expanded paths
    """

    new_list = []
    for element in elements:
        new_list.extend(expandWildcardsInItem(element))
    return flatten(new_list)


def expandWildcardsInItem(element):
    """
    Java classpaths can include wildcards (``<path>/*`` or ``<path>/*.jar``), but the way we are invoking the jvm
    directly bypasses this expansion. This will expand a classpath element into an array of elements.

    :return: an array of all the jars matching the input wildcard, or the original string if it isn't a wildcard
    """

    if not element.endswith(("/*", "/*.jar", os.path.sep + "*", os.path.sep + "*.jar")):
        return [element]

    # extract the base - everything up to the last separator (always accept /) followed by * or *.jar
    # (group 0 = anything)[slash or path.sep]star(group 1 optional .jar)
    # backslashes in regular expressions are problematic, so convert the element to / delimiters
    try:
        base = re.search("(.*)/\*(.jar)?$", element.replace("\\", "/")).group(1)
        # expand base
        return glob("{}/*.jar".format(base))
    except AttributeError:
        return [element, ]


def flatten(orig):
    """
    Converts the contents of list containing strings, lists of strings *(,lists of lists of strings,...)* to a flat
    list of strings.

    :param orig: the list to flatten
    :return: the flattened list
    """

    if isinstance(orig, str):
        return [orig, ]
    elif not hasattr(orig, '__iter__'):
        raise ValueError("The flatten method only accepts string or iterable input")

    out = []
    for x in orig:
        if isinstance(x, str):
            out.append(x)
        elif hasattr(x, '__iter__'):
            out.extend(flatten(x))
        else:
            raise ValueError("The flatten method encountered an invalid entry of type {}".format(type(x)))
    return out
