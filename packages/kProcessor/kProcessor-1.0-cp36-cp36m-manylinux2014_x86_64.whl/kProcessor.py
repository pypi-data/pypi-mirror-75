# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _kProcessor
else:
    import _kProcessor

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _kProcessor.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _kProcessor.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _kProcessor.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _kProcessor.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _kProcessor.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _kProcessor.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _kProcessor.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _kProcessor.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _kProcessor.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _kProcessor.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _kProcessor.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _kProcessor.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _kProcessor.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _kProcessor.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _kProcessor.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _kProcessor.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _kProcessor.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _kProcessor:
_kProcessor.SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _kProcessor.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _kProcessor.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _kProcessor.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _kProcessor.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _kProcessor.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _kProcessor.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _kProcessor.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _kProcessor.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _kProcessor.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _kProcessor.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _kProcessor.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _kProcessor.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _kProcessor.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _kProcessor.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _kProcessor.IntVector_rend(self)

    def clear(self) -> "void":
        return _kProcessor.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _kProcessor.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _kProcessor.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _kProcessor.IntVector_erase(self, *args)

    def __init__(self, *args):
        _kProcessor.IntVector_swiginit(self, _kProcessor.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _kProcessor.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _kProcessor.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _kProcessor.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _kProcessor.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _kProcessor.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _kProcessor.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _kProcessor.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _kProcessor.IntVector_capacity(self)
    __swig_destroy__ = _kProcessor.delete_IntVector

# Register IntVector in _kProcessor:
_kProcessor.IntVector_swigregister(IntVector)

class batchQuery_sources(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_sources_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.batchQuery_sources___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.batchQuery_sources___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::size_type":
        return _kProcessor.batchQuery_sources___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::mapped_type const &":
        return _kProcessor.batchQuery_sources___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "void":
        return _kProcessor.batchQuery_sources___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "bool":
        return _kProcessor.batchQuery_sources_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _kProcessor.batchQuery_sources_keys(self)

    def values(self) -> "PyObject *":
        return _kProcessor.batchQuery_sources_values(self)

    def items(self) -> "PyObject *":
        return _kProcessor.batchQuery_sources_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "bool":
        return _kProcessor.batchQuery_sources___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_sources_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_sources_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.batchQuery_sources___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _kProcessor.batchQuery_sources_asdict(self)

    def __init__(self, *args):
        _kProcessor.batchQuery_sources_swiginit(self, _kProcessor.new_batchQuery_sources(*args))

    def empty(self) -> "bool":
        return _kProcessor.batchQuery_sources_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::size_type":
        return _kProcessor.batchQuery_sources_size(self)

    def swap(self, v: "batchQuery_sources") -> "void":
        return _kProcessor.batchQuery_sources_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::iterator":
        return _kProcessor.batchQuery_sources_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::iterator":
        return _kProcessor.batchQuery_sources_end(self)

    def clear(self) -> "void":
        return _kProcessor.batchQuery_sources_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::allocator_type":
        return _kProcessor.batchQuery_sources_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::size_type":
        return _kProcessor.batchQuery_sources_count(self, x)

    def erase(self, *args) -> "void":
        return _kProcessor.batchQuery_sources_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::vector< unsigned int > > >::iterator":
        return _kProcessor.batchQuery_sources_find(self, x)
    __swig_destroy__ = _kProcessor.delete_batchQuery_sources

# Register batchQuery_sources in _kProcessor:
_kProcessor.batchQuery_sources_swigregister(batchQuery_sources)

class colorsList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.colorsList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.colorsList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.colorsList___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _kProcessor.colorsList___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _kProcessor.colorsList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _kProcessor.colorsList___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _kProcessor.colorsList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _kProcessor.colorsList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _kProcessor.colorsList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.colorsList___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _kProcessor.colorsList_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _kProcessor.colorsList_append(self, x)

    def empty(self) -> "bool":
        return _kProcessor.colorsList_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _kProcessor.colorsList_size(self)

    def swap(self, v: "colorsList") -> "void":
        return _kProcessor.colorsList_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _kProcessor.colorsList_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _kProcessor.colorsList_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _kProcessor.colorsList_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _kProcessor.colorsList_rend(self)

    def clear(self) -> "void":
        return _kProcessor.colorsList_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _kProcessor.colorsList_get_allocator(self)

    def pop_back(self) -> "void":
        return _kProcessor.colorsList_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _kProcessor.colorsList_erase(self, *args)

    def __init__(self, *args):
        _kProcessor.colorsList_swiginit(self, _kProcessor.new_colorsList(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _kProcessor.colorsList_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _kProcessor.colorsList_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _kProcessor.colorsList_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _kProcessor.colorsList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _kProcessor.colorsList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _kProcessor.colorsList_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _kProcessor.colorsList_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _kProcessor.colorsList_capacity(self)
    __swig_destroy__ = _kProcessor.delete_colorsList

# Register colorsList in _kProcessor:
_kProcessor.colorsList_swigregister(colorsList)

class batchQuery_counts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_counts_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.batchQuery_counts___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.batchQuery_counts___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::vector< unsigned int > >::size_type":
        return _kProcessor.batchQuery_counts___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "std::unordered_map< std::string,std::vector< unsigned int > >::mapped_type const &":
        return _kProcessor.batchQuery_counts___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "void":
        return _kProcessor.batchQuery_counts___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "bool":
        return _kProcessor.batchQuery_counts_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _kProcessor.batchQuery_counts_keys(self)

    def values(self) -> "PyObject *":
        return _kProcessor.batchQuery_counts_values(self)

    def items(self) -> "PyObject *":
        return _kProcessor.batchQuery_counts_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "bool":
        return _kProcessor.batchQuery_counts___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_counts_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.batchQuery_counts_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.batchQuery_counts___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _kProcessor.batchQuery_counts_asdict(self)

    def __init__(self, *args):
        _kProcessor.batchQuery_counts_swiginit(self, _kProcessor.new_batchQuery_counts(*args))

    def empty(self) -> "bool":
        return _kProcessor.batchQuery_counts_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::vector< unsigned int > >::size_type":
        return _kProcessor.batchQuery_counts_size(self)

    def swap(self, v: "batchQuery_counts") -> "void":
        return _kProcessor.batchQuery_counts_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::vector< unsigned int > >::iterator":
        return _kProcessor.batchQuery_counts_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::vector< unsigned int > >::iterator":
        return _kProcessor.batchQuery_counts_end(self)

    def clear(self) -> "void":
        return _kProcessor.batchQuery_counts_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::vector< unsigned int > >::allocator_type":
        return _kProcessor.batchQuery_counts_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "std::unordered_map< std::string,std::vector< unsigned int > >::size_type":
        return _kProcessor.batchQuery_counts_count(self, x)

    def erase(self, *args) -> "void":
        return _kProcessor.batchQuery_counts_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::vector< unsigned int > >::key_type const &") -> "std::unordered_map< std::string,std::vector< unsigned int > >::iterator":
        return _kProcessor.batchQuery_counts_find(self, x)
    __swig_destroy__ = _kProcessor.delete_batchQuery_counts

# Register batchQuery_counts in _kProcessor:
_kProcessor.batchQuery_counts_swigregister(batchQuery_counts)

class kmerDecoderParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.kmerDecoderParams_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.kmerDecoderParams___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.kmerDecoderParams___bool__(self)

    def __len__(self) -> "std::map< std::string,int >::size_type":
        return _kProcessor.kmerDecoderParams___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::mapped_type const &":
        return _kProcessor.kmerDecoderParams___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,int >::key_type const &") -> "void":
        return _kProcessor.kmerDecoderParams___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,int >::key_type const &") -> "bool":
        return _kProcessor.kmerDecoderParams_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _kProcessor.kmerDecoderParams_keys(self)

    def values(self) -> "PyObject *":
        return _kProcessor.kmerDecoderParams_values(self)

    def items(self) -> "PyObject *":
        return _kProcessor.kmerDecoderParams_items(self)

    def __contains__(self, key: "std::map< std::string,int >::key_type const &") -> "bool":
        return _kProcessor.kmerDecoderParams___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.kmerDecoderParams_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.kmerDecoderParams_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.kmerDecoderParams___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _kProcessor.kmerDecoderParams_asdict(self)

    def __init__(self, *args):
        _kProcessor.kmerDecoderParams_swiginit(self, _kProcessor.new_kmerDecoderParams(*args))

    def empty(self) -> "bool":
        return _kProcessor.kmerDecoderParams_empty(self)

    def size(self) -> "std::map< std::string,int >::size_type":
        return _kProcessor.kmerDecoderParams_size(self)

    def swap(self, v: "kmerDecoderParams") -> "void":
        return _kProcessor.kmerDecoderParams_swap(self, v)

    def begin(self) -> "std::map< std::string,int >::iterator":
        return _kProcessor.kmerDecoderParams_begin(self)

    def end(self) -> "std::map< std::string,int >::iterator":
        return _kProcessor.kmerDecoderParams_end(self)

    def rbegin(self) -> "std::map< std::string,int >::reverse_iterator":
        return _kProcessor.kmerDecoderParams_rbegin(self)

    def rend(self) -> "std::map< std::string,int >::reverse_iterator":
        return _kProcessor.kmerDecoderParams_rend(self)

    def clear(self) -> "void":
        return _kProcessor.kmerDecoderParams_clear(self)

    def get_allocator(self) -> "std::map< std::string,int >::allocator_type":
        return _kProcessor.kmerDecoderParams_get_allocator(self)

    def count(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::size_type":
        return _kProcessor.kmerDecoderParams_count(self, x)

    def erase(self, *args) -> "void":
        return _kProcessor.kmerDecoderParams_erase(self, *args)

    def find(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _kProcessor.kmerDecoderParams_find(self, x)

    def lower_bound(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _kProcessor.kmerDecoderParams_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _kProcessor.kmerDecoderParams_upper_bound(self, x)
    __swig_destroy__ = _kProcessor.delete_kmerDecoderParams

# Register kmerDecoderParams in _kProcessor:
_kProcessor.kmerDecoderParams_swigregister(kmerDecoderParams)

class kDataFrameIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kDataFrameIterator_swiginit(self, _kProcessor.new_kDataFrameIterator(*args))

    def next(self) -> "kDataFrameIterator &":
        return _kProcessor.kDataFrameIterator_next(self)

    def __eq__(self, other: "kDataFrameIterator") -> "bool":
        return _kProcessor.kDataFrameIterator___eq__(self, other)

    def __ne__(self, other: "kDataFrameIterator") -> "bool":
        return _kProcessor.kDataFrameIterator___ne__(self, other)

    def getHashedKmer(self) -> "uint64_t":
        return _kProcessor.kDataFrameIterator_getHashedKmer(self)

    def getKmer(self) -> "std::string":
        return _kProcessor.kDataFrameIterator_getKmer(self)

    def getCount(self) -> "uint64_t":
        return _kProcessor.kDataFrameIterator_getCount(self)

    def setCount(self, count: "uint64_t") -> "bool":
        return _kProcessor.kDataFrameIterator_setCount(self, count)

    def __ref__(self) -> "kmerRow":
        return _kProcessor.kDataFrameIterator___ref__(self)
    __swig_destroy__ = _kProcessor.delete_kDataFrameIterator

# Register kDataFrameIterator in _kProcessor:
_kProcessor.kDataFrameIterator_swigregister(kDataFrameIterator)

class kmerRow(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kmer = property(_kProcessor.kmerRow_kmer_get, _kProcessor.kmerRow_kmer_set)
    hashedKmer = property(_kProcessor.kmerRow_hashedKmer_get, _kProcessor.kmerRow_hashedKmer_set)
    count = property(_kProcessor.kmerRow_count_get, _kProcessor.kmerRow_count_set)

    def __init__(self, *args):
        _kProcessor.kmerRow_swiginit(self, _kProcessor.new_kmerRow(*args))

    def copy(self, other: "kmerRow") -> "kmerRow":
        return _kProcessor.kmerRow_copy(self, other)

    def __eq__(self, other: "kmerRow") -> "bool":
        return _kProcessor.kmerRow___eq__(self, other)

    def __lt__(self, *args) -> "bool":
        return _kProcessor.kmerRow___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        return _kProcessor.kmerRow___gt__(self, *args)
    __swig_destroy__ = _kProcessor.delete_kmerRow

# Register kmerRow in _kProcessor:
_kProcessor.kmerRow_swigregister(kmerRow)

class kDataFrame(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _kProcessor.delete_kDataFrame

    def getTwin(self) -> "kDataFrame *":
        return _kProcessor.kDataFrame_getTwin(self)

    def reserve(self, n: "uint64_t") -> "void":
        return _kProcessor.kDataFrame_reserve(self, n)

    def insert(self, *args) -> "bool":
        return _kProcessor.kDataFrame_insert(self, *args)

    def setCount(self, kmer: "std::string", N: "uint64_t") -> "bool":
        return _kProcessor.kDataFrame_setCount(self, kmer, N)

    def getCount(self, kmer: "std::string") -> "uint64_t":
        return _kProcessor.kDataFrame_getCount(self, kmer)

    def erase(self, kmer: "std::string") -> "bool":
        return _kProcessor.kDataFrame_erase(self, kmer)

    def size(self) -> "uint64_t":
        return _kProcessor.kDataFrame_size(self)

    def max_size(self) -> "uint64_t":
        return _kProcessor.kDataFrame_max_size(self)

    def empty(self) -> "bool":
        return _kProcessor.kDataFrame_empty(self)

    def load_factor(self) -> "float":
        return _kProcessor.kDataFrame_load_factor(self)

    def max_load_factor(self) -> "float":
        return _kProcessor.kDataFrame_max_load_factor(self)

    def begin(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrame_begin(self)

    def end(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrame_end(self)

    def save(self, filePath: "std::string") -> "void":
        return _kProcessor.kDataFrame_save(self, filePath)

    def getkmerDecoder(self) -> "kmerDecoder *":
        return _kProcessor.kDataFrame_getkmerDecoder(self)

    @staticmethod
    def load(filePath: "std::string") -> "kDataFrame *":
        return _kProcessor.kDataFrame_load(filePath)

    def ksize(self) -> "uint64_t":
        return _kProcessor.kDataFrame_ksize(self)

    def setkSize(self, k: "uint64_t") -> "void":
        return _kProcessor.kDataFrame_setkSize(self, k)

    def addColumn_int(self, columnName: "std::string") -> "void":
        return _kProcessor.kDataFrame_addColumn_int(self, columnName)

    def addColumn_bool(self, columnName: "std::string") -> "void":
        return _kProcessor.kDataFrame_addColumn_bool(self, columnName)

    def addColumn_double(self, columnName: "std::string") -> "void":
        return _kProcessor.kDataFrame_addColumn_double(self, columnName)

    def getKmerColumnValue_int(self, columnName: "std::string", kmer: "std::string") -> "int":
        return _kProcessor.kDataFrame_getKmerColumnValue_int(self, columnName, kmer)

    def getKmerColumnValue_bool(self, columnName: "std::string", kmer: "std::string") -> "bool":
        return _kProcessor.kDataFrame_getKmerColumnValue_bool(self, columnName, kmer)

    def getKmerColumnValue_double(self, columnName: "std::string", kmer: "std::string") -> "double":
        return _kProcessor.kDataFrame_getKmerColumnValue_double(self, columnName, kmer)

    def setKmerColumnValue_int(self, columnName: "std::string", kmer: "std::string", value: "int") -> "void":
        return _kProcessor.kDataFrame_setKmerColumnValue_int(self, columnName, kmer, value)

    def setKmerColumnValue_bool(self, columnName: "std::string", kmer: "std::string", value: "bool") -> "void":
        return _kProcessor.kDataFrame_setKmerColumnValue_bool(self, columnName, kmer, value)

    def setKmerColumnValue_double(self, columnName: "std::string", kmer: "std::string", value: "double") -> "void":
        return _kProcessor.kDataFrame_setKmerColumnValue_double(self, columnName, kmer, value)

# Register kDataFrame in _kProcessor:
_kProcessor.kDataFrame_swigregister(kDataFrame)

def kDataFrame_load(filePath: "std::string") -> "kDataFrame *":
    return _kProcessor.kDataFrame_load(filePath)

class kDataFrameMQF(kDataFrame):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kDataFrameMQF_swiginit(self, _kProcessor.new_kDataFrameMQF(*args))
    __swig_destroy__ = _kProcessor.delete_kDataFrameMQF

    def reserve(self, n: "uint64_t") -> "void":
        return _kProcessor.kDataFrameMQF_reserve(self, n)

    def getTwin(self) -> "kDataFrame *":
        return _kProcessor.kDataFrameMQF_getTwin(self)

    def setCount(self, *args) -> "bool":
        return _kProcessor.kDataFrameMQF_setCount(self, *args)

    def insert(self, *args) -> "bool":
        return _kProcessor.kDataFrameMQF_insert(self, *args)

    def getCount(self, *args) -> "uint64_t":
        return _kProcessor.kDataFrameMQF_getCount(self, *args)

    def erase(self, *args) -> "bool":
        return _kProcessor.kDataFrameMQF_erase(self, *args)

    def size(self) -> "uint64_t":
        return _kProcessor.kDataFrameMQF_size(self)

    def max_size(self) -> "uint64_t":
        return _kProcessor.kDataFrameMQF_max_size(self)

    def load_factor(self) -> "float":
        return _kProcessor.kDataFrameMQF_load_factor(self)

    def max_load_factor(self) -> "float":
        return _kProcessor.kDataFrameMQF_max_load_factor(self)

    def getMQF(self) -> "QF *":
        return _kProcessor.kDataFrameMQF_getMQF(self)

    def save(self, filePath: "std::string") -> "void":
        return _kProcessor.kDataFrameMQF_save(self, filePath)

    @staticmethod
    def load(filePath: "std::string") -> "kDataFrame *":
        return _kProcessor.kDataFrameMQF_load(filePath)

    def begin(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameMQF_begin(self)

    def end(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameMQF_end(self)

# Register kDataFrameMQF in _kProcessor:
_kProcessor.kDataFrameMQF_swigregister(kDataFrameMQF)

def kDataFrameMQF_load(filePath: "std::string") -> "kDataFrame *":
    return _kProcessor.kDataFrameMQF_load(filePath)

class kDataFrameMAP(kDataFrame):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kDataFrameMAP_swiginit(self, _kProcessor.new_kDataFrameMAP(*args))

    def getTwin(self) -> "kDataFrame *":
        return _kProcessor.kDataFrameMAP_getTwin(self)

    def reserve(self, n: "uint64_t") -> "void":
        return _kProcessor.kDataFrameMAP_reserve(self, n)

    def setCount(self, kmer: "std::string", count: "uint64_t") -> "bool":
        return _kProcessor.kDataFrameMAP_setCount(self, kmer, count)

    def insert(self, *args) -> "bool":
        return _kProcessor.kDataFrameMAP_insert(self, *args)

    def getCount(self, kmer: "std::string") -> "uint64_t":
        return _kProcessor.kDataFrameMAP_getCount(self, kmer)

    def erase(self, kmer: "std::string") -> "bool":
        return _kProcessor.kDataFrameMAP_erase(self, kmer)

    def size(self) -> "uint64_t":
        return _kProcessor.kDataFrameMAP_size(self)

    def max_size(self) -> "uint64_t":
        return _kProcessor.kDataFrameMAP_max_size(self)

    def load_factor(self) -> "float":
        return _kProcessor.kDataFrameMAP_load_factor(self)

    def max_load_factor(self) -> "float":
        return _kProcessor.kDataFrameMAP_max_load_factor(self)

    def begin(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameMAP_begin(self)

    def end(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameMAP_end(self)

    def bucket(self, kmer: "std::string") -> "uint64_t":
        return _kProcessor.kDataFrameMAP_bucket(self, kmer)

    def save(self, filePath: "std::string") -> "void":
        return _kProcessor.kDataFrameMAP_save(self, filePath)

    @staticmethod
    def load(filePath: "std::string") -> "kDataFrame *":
        return _kProcessor.kDataFrameMAP_load(filePath)
    __swig_destroy__ = _kProcessor.delete_kDataFrameMAP

# Register kDataFrameMAP in _kProcessor:
_kProcessor.kDataFrameMAP_swigregister(kDataFrameMAP)

def kDataFrameMAP_load(filePath: "std::string") -> "kDataFrame *":
    return _kProcessor.kDataFrameMAP_load(filePath)

class kDataFramePHMAP(kDataFrame):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kDataFramePHMAP_swiginit(self, _kProcessor.new_kDataFramePHMAP(*args))

    def getTwin(self) -> "kDataFrame *":
        return _kProcessor.kDataFramePHMAP_getTwin(self)

    def reserve(self, n: "uint64_t") -> "void":
        return _kProcessor.kDataFramePHMAP_reserve(self, n)

    def setCount(self, kmer: "std::string", count: "uint64_t") -> "bool":
        return _kProcessor.kDataFramePHMAP_setCount(self, kmer, count)

    def insert(self, *args) -> "bool":
        return _kProcessor.kDataFramePHMAP_insert(self, *args)

    def getCount(self, kmer: "std::string") -> "uint64_t":
        return _kProcessor.kDataFramePHMAP_getCount(self, kmer)

    def erase(self, kmer: "std::string") -> "bool":
        return _kProcessor.kDataFramePHMAP_erase(self, kmer)

    def size(self) -> "uint64_t":
        return _kProcessor.kDataFramePHMAP_size(self)

    def max_size(self) -> "uint64_t":
        return _kProcessor.kDataFramePHMAP_max_size(self)

    def load_factor(self) -> "float":
        return _kProcessor.kDataFramePHMAP_load_factor(self)

    def max_load_factor(self) -> "float":
        return _kProcessor.kDataFramePHMAP_max_load_factor(self)

    def begin(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFramePHMAP_begin(self)

    def end(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFramePHMAP_end(self)

    def bucket(self, kmer: "std::string") -> "uint64_t":
        return _kProcessor.kDataFramePHMAP_bucket(self, kmer)

    def save(self, filePath: "std::string") -> "void":
        return _kProcessor.kDataFramePHMAP_save(self, filePath)

    @staticmethod
    def load(filePath: "std::string") -> "kDataFrame *":
        return _kProcessor.kDataFramePHMAP_load(filePath)
    __swig_destroy__ = _kProcessor.delete_kDataFramePHMAP

# Register kDataFramePHMAP in _kProcessor:
_kProcessor.kDataFramePHMAP_swigregister(kDataFramePHMAP)

def kDataFramePHMAP_load(filePath: "std::string") -> "kDataFrame *":
    return _kProcessor.kDataFramePHMAP_load(filePath)

class kDataFrameBMQF(kDataFrame):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kDataFrameBMQF_swiginit(self, _kProcessor.new_kDataFrameBMQF(*args))
    __swig_destroy__ = _kProcessor.delete_kDataFrameBMQF

    def reserve(self, n: "uint64_t") -> "void":
        return _kProcessor.kDataFrameBMQF_reserve(self, n)

    def getTwin(self) -> "kDataFrame *":
        return _kProcessor.kDataFrameBMQF_getTwin(self)

    def insert(self, *args) -> "bool":
        return _kProcessor.kDataFrameBMQF_insert(self, *args)

    def setCount(self, *args) -> "bool":
        return _kProcessor.kDataFrameBMQF_setCount(self, *args)

    def getCount(self, *args) -> "uint64_t":
        return _kProcessor.kDataFrameBMQF_getCount(self, *args)

    def erase(self, *args) -> "bool":
        return _kProcessor.kDataFrameBMQF_erase(self, *args)

    def size(self) -> "uint64_t":
        return _kProcessor.kDataFrameBMQF_size(self)

    def max_size(self) -> "uint64_t":
        return _kProcessor.kDataFrameBMQF_max_size(self)

    def load_factor(self) -> "float":
        return _kProcessor.kDataFrameBMQF_load_factor(self)

    def max_load_factor(self) -> "float":
        return _kProcessor.kDataFrameBMQF_max_load_factor(self)

    def getBMQF(self) -> "bufferedMQF *":
        return _kProcessor.kDataFrameBMQF_getBMQF(self)

    def save(self, filePath: "std::string") -> "void":
        return _kProcessor.kDataFrameBMQF_save(self, filePath)

    @staticmethod
    def load(filePath: "std::string") -> "kDataFrame *":
        return _kProcessor.kDataFrameBMQF_load(filePath)

    def begin(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameBMQF_begin(self)

    def end(self) -> "kDataFrameIterator":
        return _kProcessor.kDataFrameBMQF_end(self)

    def find(self, kmer: "std::string") -> "kDataFrameIterator":
        return _kProcessor.kDataFrameBMQF_find(self, kmer)

# Register kDataFrameBMQF in _kProcessor:
_kProcessor.kDataFrameBMQF_swigregister(kDataFrameBMQF)

def kDataFrameBMQF_load(filePath: "std::string") -> "kDataFrame *":
    return _kProcessor.kDataFrameBMQF_load(filePath)

class colored_kDataFrame(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _kProcessor.colored_kDataFrame_swiginit(self, _kProcessor.new_colored_kDataFrame())

    def addNewColor(self, color: "uint32_t", samplesIds: "colorsList") -> "void":
        return _kProcessor.colored_kDataFrame_addNewColor(self, color, samplesIds)

    def setColor(self, kmer: "std::string", color: "uint32_t") -> "void":
        return _kProcessor.colored_kDataFrame_setColor(self, kmer, color)

    def getColor(self, kmer: "std::string") -> "uint32_t":
        return _kProcessor.colored_kDataFrame_getColor(self, kmer)

    def getKmerSource(self, kmer: "std::string") -> "std::vector< uint32_t >":
        return _kProcessor.colored_kDataFrame_getKmerSource(self, kmer)

    def getKmerSourceFromColor(self, color: "uint32_t") -> "std::vector< uint32_t >":
        return _kProcessor.colored_kDataFrame_getKmerSourceFromColor(self, color)

    def colorKmer(self, kmer: "std::string", samplesIds: "colorsList") -> "void":
        return _kProcessor.colored_kDataFrame_colorKmer(self, kmer, samplesIds)

    def setColorTable(self, table: "colorTable") -> "void":
        return _kProcessor.colored_kDataFrame_setColorTable(self, table)

    def setkDataFrame(self, f: "kDataFrame") -> "void":
        return _kProcessor.colored_kDataFrame_setkDataFrame(self, f)

    def save(self, prefix: "std::string") -> "void":
        return _kProcessor.colored_kDataFrame_save(self, prefix)

    @staticmethod
    def load(prefix: "std::string") -> "colored_kDataFrame *":
        return _kProcessor.colored_kDataFrame_load(prefix)

    def getkSize(self) -> "uint64_t":
        return _kProcessor.colored_kDataFrame_getkSize(self)

    def names_map(self) -> "std::unordered_map< int,std::string >":
        return _kProcessor.colored_kDataFrame_names_map(self)

    def inverse_names_map(self) -> "std::unordered_map< std::string,int >":
        return _kProcessor.colored_kDataFrame_inverse_names_map(self)

    def getkDataFrame(self) -> "kDataFrame *":
        return _kProcessor.colored_kDataFrame_getkDataFrame(self)
    __swig_destroy__ = _kProcessor.delete_colored_kDataFrame

# Register colored_kDataFrame in _kProcessor:
_kProcessor.colored_kDataFrame_swigregister(colored_kDataFrame)

def colored_kDataFrame_load(prefix: "std::string") -> "colored_kDataFrame *":
    return _kProcessor.colored_kDataFrame_load(prefix)

class colorTable(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _kProcessor.delete_colorTable

    @staticmethod
    def load(folderName: "std::string") -> "colorTable *":
        return _kProcessor.colorTable_load(folderName)

    def getSamples(self, colorID: "uint64_t", res: "colorsList") -> "bool":
        return _kProcessor.colorTable_getSamples(self, colorID, res)

    def setColor(self, colorID: "uint64_t", v: "colorsList") -> "bool":
        return _kProcessor.colorTable_setColor(self, colorID, v)

    def save(self, folderName: "std::string") -> "void":
        return _kProcessor.colorTable_save(self, folderName)
    numSamples = property(_kProcessor.colorTable_numSamples_get, _kProcessor.colorTable_numSamples_set)
    numColors = property(_kProcessor.colorTable_numColors_get, _kProcessor.colorTable_numColors_set)

# Register colorTable in _kProcessor:
_kProcessor.colorTable_swigregister(colorTable)

def colorTable_load(folderName: "std::string") -> "colorTable *":
    return _kProcessor.colorTable_load(folderName)

class colorTableInv(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _kProcessor.delete_colorTableInv

    def getColorId(self, arg2: "colorsList") -> "uint64_t":
        return _kProcessor.colorTableInv_getColorId(self, arg2)

    def setColorId(self, colorID: "uint64_t", v: "colorsList") -> "void":
        return _kProcessor.colorTableInv_setColorId(self, colorID, v)

# Register colorTableInv in _kProcessor:
_kProcessor.colorTableInv_swigregister(colorTableInv)

class intVectorsTable(colorTable):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.intVectorsTable_swiginit(self, _kProcessor.new_intVectorsTable(*args))
    __swig_destroy__ = _kProcessor.delete_intVectorsTable

    def getSamples(self, colorID: "uint64_t", res: "colorsList") -> "bool":
        return _kProcessor.intVectorsTable_getSamples(self, colorID, res)

    def setColor(self, colorID: "uint64_t", v: "colorsList") -> "bool":
        return _kProcessor.intVectorsTable_setColor(self, colorID, v)

    def save(self, folderName: "std::string") -> "void":
        return _kProcessor.intVectorsTable_save(self, folderName)

# Register intVectorsTable in _kProcessor:
_kProcessor.intVectorsTable_swigregister(intVectorsTable)

class kf_batchQuery(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _kProcessor.kf_batchQuery_swiginit(self, _kProcessor.new_kf_batchQuery(*args))

    def next(self) -> "void":
        return _kProcessor.kf_batchQuery_next(self)

    def end(self) -> "bool":
        return _kProcessor.kf_batchQuery_end(self)

    def get_transcripts(self) -> "std::unordered_map< std::string,std::vector< uint32_t > >":
        return _kProcessor.kf_batchQuery_get_transcripts(self)
    __swig_destroy__ = _kProcessor.delete_kf_batchQuery

# Register kf_batchQuery in _kProcessor:
_kProcessor.kf_batchQuery_swigregister(kf_batchQuery)

class ckf_batchQuery(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ckFrame: "colored_kDataFrame", filename: "std::string", parse_params: "kmerDecoderParams", chunk_size: "int"=500):
        _kProcessor.ckf_batchQuery_swiginit(self, _kProcessor.new_ckf_batchQuery(ckFrame, filename, parse_params, chunk_size))

    def next(self) -> "void":
        return _kProcessor.ckf_batchQuery_next(self)

    def end(self) -> "bool":
        return _kProcessor.ckf_batchQuery_end(self)

    def get_transcripts(self) -> "std::unordered_map< std::string,std::vector< std::vector< uint32_t > > >":
        return _kProcessor.ckf_batchQuery_get_transcripts(self)
    __swig_destroy__ = _kProcessor.delete_ckf_batchQuery

# Register ckf_batchQuery in _kProcessor:
_kProcessor.ckf_batchQuery_swigregister(ckf_batchQuery)

class kFramesVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _kProcessor.kFramesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _kProcessor.kFramesVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _kProcessor.kFramesVector___bool__(self)

    def __len__(self) -> "std::vector< kDataFrame * >::size_type":
        return _kProcessor.kFramesVector___len__(self)

    def __getslice__(self, i: "std::vector< kDataFrame * >::difference_type", j: "std::vector< kDataFrame * >::difference_type") -> "std::vector< kDataFrame *,std::allocator< kDataFrame * > > *":
        return _kProcessor.kFramesVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _kProcessor.kFramesVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< kDataFrame * >::difference_type", j: "std::vector< kDataFrame * >::difference_type") -> "void":
        return _kProcessor.kFramesVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _kProcessor.kFramesVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< kDataFrame * >::value_type":
        return _kProcessor.kFramesVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _kProcessor.kFramesVector___setitem__(self, *args)

    def pop(self) -> "std::vector< kDataFrame * >::value_type":
        return _kProcessor.kFramesVector_pop(self)

    def append(self, x: "kDataFrame") -> "void":
        return _kProcessor.kFramesVector_append(self, x)

    def empty(self) -> "bool":
        return _kProcessor.kFramesVector_empty(self)

    def size(self) -> "std::vector< kDataFrame * >::size_type":
        return _kProcessor.kFramesVector_size(self)

    def swap(self, v: "kFramesVector") -> "void":
        return _kProcessor.kFramesVector_swap(self, v)

    def begin(self) -> "std::vector< kDataFrame * >::iterator":
        return _kProcessor.kFramesVector_begin(self)

    def end(self) -> "std::vector< kDataFrame * >::iterator":
        return _kProcessor.kFramesVector_end(self)

    def rbegin(self) -> "std::vector< kDataFrame * >::reverse_iterator":
        return _kProcessor.kFramesVector_rbegin(self)

    def rend(self) -> "std::vector< kDataFrame * >::reverse_iterator":
        return _kProcessor.kFramesVector_rend(self)

    def clear(self) -> "void":
        return _kProcessor.kFramesVector_clear(self)

    def get_allocator(self) -> "std::vector< kDataFrame * >::allocator_type":
        return _kProcessor.kFramesVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _kProcessor.kFramesVector_pop_back(self)

    def erase(self, *args) -> "std::vector< kDataFrame * >::iterator":
        return _kProcessor.kFramesVector_erase(self, *args)

    def __init__(self, *args):
        _kProcessor.kFramesVector_swiginit(self, _kProcessor.new_kFramesVector(*args))

    def push_back(self, x: "kDataFrame") -> "void":
        return _kProcessor.kFramesVector_push_back(self, x)

    def front(self) -> "std::vector< kDataFrame * >::value_type":
        return _kProcessor.kFramesVector_front(self)

    def back(self) -> "std::vector< kDataFrame * >::value_type":
        return _kProcessor.kFramesVector_back(self)

    def assign(self, n: "std::vector< kDataFrame * >::size_type", x: "kDataFrame") -> "void":
        return _kProcessor.kFramesVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _kProcessor.kFramesVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _kProcessor.kFramesVector_insert(self, *args)

    def reserve(self, n: "std::vector< kDataFrame * >::size_type") -> "void":
        return _kProcessor.kFramesVector_reserve(self, n)

    def capacity(self) -> "std::vector< kDataFrame * >::size_type":
        return _kProcessor.kFramesVector_capacity(self)
    __swig_destroy__ = _kProcessor.delete_kFramesVector

# Register kFramesVector in _kProcessor:
_kProcessor.kFramesVector_swigregister(kFramesVector)


def kFrameUnion(input: "kFramesVector") -> "kDataFrame *":
    return _kProcessor.kFrameUnion(input)

def kFrameIntersect(input: "kFramesVector") -> "kDataFrame *":
    return _kProcessor.kFrameIntersect(input)

def kFrameDiff(input: "kFramesVector") -> "kDataFrame *":
    return _kProcessor.kFrameDiff(input)

def kmerDecoder_setHashing(KF: "kDataFrame", hash_mode: "int", canonical: "bool"=True) -> "void":
    return _kProcessor.kmerDecoder_setHashing(KF, hash_mode, canonical)

def countKmersFromString(kframe: "kDataFrame", params: "kmerDecoderParams", sequence: "std::string") -> "void":
    return _kProcessor.countKmersFromString(kframe, params, sequence)

def countKmersFromFile(kframe: "kDataFrame", params: "kmerDecoderParams", filename: "std::string", chunk_size: "int"=1000) -> "void":
    return _kProcessor.countKmersFromFile(kframe, params, filename, chunk_size)

def index(kframe: "kDataFrame", params: "kmerDecoderParams", filename: "std::string", chunks: "int", names_fileName: "std::string") -> "colored_kDataFrame *":
    return _kProcessor.index(kframe, params, filename, chunks, names_fileName)
class Hasher(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def hash(self, *args) -> "uint64_t":
        return _kProcessor.Hasher_hash(self, *args)

    def Ihash(self, key: "uint64_t") -> "std::string":
        return _kProcessor.Hasher_Ihash(self, key)

    def clone(self) -> "Hasher *":
        return _kProcessor.Hasher_clone(self)

    def __init__(self):
        _kProcessor.Hasher_swiginit(self, _kProcessor.new_Hasher())
    __swig_destroy__ = _kProcessor.delete_Hasher

# Register Hasher in _kProcessor:
_kProcessor.Hasher_swigregister(Hasher)

class TwoBitsHasher(Hasher):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, kSize: "uint64_t"):
        _kProcessor.TwoBitsHasher_swiginit(self, _kProcessor.new_TwoBitsHasher(kSize))

    def clone(self) -> "Hasher *":
        return _kProcessor.TwoBitsHasher_clone(self)

    def hash(self, *args) -> "uint64_t":
        return _kProcessor.TwoBitsHasher_hash(self, *args)

    def Ihash(self, key: "uint64_t") -> "std::string":
        return _kProcessor.TwoBitsHasher_Ihash(self, key)
    __swig_destroy__ = _kProcessor.delete_TwoBitsHasher

# Register TwoBitsHasher in _kProcessor:
_kProcessor.TwoBitsHasher_swigregister(TwoBitsHasher)

class kmer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def str_to_int(str: "std::string") -> "uint64_t":
        return _kProcessor.kmer_str_to_int(str)

    @staticmethod
    def str_to_canonical_int(str: "std::string") -> "uint64_t":
        return _kProcessor.kmer_str_to_canonical_int(str)

    @staticmethod
    def canonicalKmer(k: "std::string") -> "std::string":
        return _kProcessor.kmer_canonicalKmer(k)

    @staticmethod
    def int_to_str(kmer: "uint64_t", K: "uint32_t") -> "std::string":
        return _kProcessor.kmer_int_to_str(kmer, K)

    @staticmethod
    def reverse_complement(kmer: "uint64_t", K: "uint32_t") -> "uint64_t":
        return _kProcessor.kmer_reverse_complement(kmer, K)
    __swig_destroy__ = _kProcessor.delete_kmer

# Register kmer in _kProcessor:
_kProcessor.kmer_swigregister(kmer)

def kmer_str_to_int(str: "std::string") -> "uint64_t":
    return _kProcessor.kmer_str_to_int(str)

def kmer_str_to_canonical_int(str: "std::string") -> "uint64_t":
    return _kProcessor.kmer_str_to_canonical_int(str)

def kmer_canonicalKmer(k: "std::string") -> "std::string":
    return _kProcessor.kmer_canonicalKmer(k)

def kmer_int_to_str(kmer: "uint64_t", K: "uint32_t") -> "std::string":
    return _kProcessor.kmer_int_to_str(kmer, K)

def kmer_reverse_complement(kmer: "uint64_t", K: "uint32_t") -> "uint64_t":
    return _kProcessor.kmer_reverse_complement(kmer, K)



