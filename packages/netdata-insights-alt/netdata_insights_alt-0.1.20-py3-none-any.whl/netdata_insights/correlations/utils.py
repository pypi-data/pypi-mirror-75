# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/correlations.utils.ipynb (unless otherwise specified).

__all__ = ['log', 'try_fit', 'get_col_map', 'save_results', 'normalize_results', 'validate_data']

# Cell

import logging
import math

import pandas as pd

log = logging.getLogger(__name__)

# Cell


def try_fit(clf, colname, data, default_model, model_errors='default'):
    try:
        clf.fit(data)
        result = 'success'
    except Exception as e:
        if model_errors == 'default':
            log.warning(f"... warning: could not fit model for {colname}, trying default")
            clf = default_model()
            clf.fit(data)
            result = 'default'
        elif model_errors == 'ignore':
            log.warning(f"... warning: could not fit model for {colname}, skipping")
            result = 'ignore'
        else:
            log.error(f"... error: fit failed for clf={clf}")
            log.error(e)
            raise e
    return clf, result



# Cell


def get_col_map(colnames, model_level):
    col_map = {}
    if model_level == 'chart':
        charts_list = list(set([colname.split('|')[0] for colname in colnames]))
        for chart in charts_list:
            col_map[chart] = [colnames.index(colname) for colname in colnames if colname.startswith(f'{chart}|')]
    else:
        for col in colnames:
            col_map[col] = [colnames.index(colname) for colname in colnames if colname == col]
    return col_map



# Cell


def save_results(results, chart, dimension, score):
    if "data" not in results:
        results["data"] = {}
    if chart in results["data"]:
        results["data"][chart].update({dimension: {"score": round(score, 4)}})
    else:
        results["data"][chart] = {dimension: {"score": round(score, 4)}}
    return results



# Cell


def normalize_results(results):
    # get max and min scores
    scores = []
    for chart in results['data']:
        for dimension in results['data'][chart]:
            scores.append(results['data'][chart][dimension]['score'])
    score_max = max(scores)
    score_min = min(scores)
    # normalize scores
    for chart in results['data']:
        for dimension in results['data'][chart]:
            score = results['data'][chart][dimension]['score']
            if ( score_max == score_min or math.isnan(score_max) or math.isnan(score_min) or math.isnan(score) ):
                score_norm = round(0.0, 4)
            else:
                score_norm = round((score - score_min) / (score_max - score_min), 4)
            results['data'][chart][dimension]['score_norm'] = score_norm
    return results



# Cell


def validate_data(baseline_data, highlight_data):
    bad_data = False
    if isinstance(baseline_data, pd.DataFrame):
        baseline_na_pct = max(baseline_data.isna().sum() / len(baseline_data))
        highlight_na_pct = max(highlight_data.isna().sum() / len(highlight_data))
        if baseline_na_pct >= 0.1:
            bad_data = True
        if highlight_na_pct >= 0.1:
            bad_data = True
    return bad_data

