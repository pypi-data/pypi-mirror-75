# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_image_infra_fdu__fdu_record_image(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/image. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Imange used when instatiating the FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__uri','__checksum','__format',)

  _yang_name = 'image'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'image']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /fdu_record/image/uuid (string)

    YANG Description: UUID for the image
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /fdu_record/image/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: UUID for the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /fdu_record/image/name (string)

    YANG Description: Name of the image
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /fdu_record/image/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /fdu_record/image/uri (string)

    YANG Description: The URI for the image
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /fdu_record/image/uri (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: The URI for the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /fdu_record/image/checksum (string)

    YANG Description: SHA1 checksum of the image file
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /fdu_record/image/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: SHA1 checksum of the image file
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_format(self):
    """
    Getter method for format, mapped from YANG variable /fdu_record/image/format (string)

    YANG Description: The format of the image
    """
    return self.__format
      
  def _set_format(self, v, load=False):
    """
    Setter method for format, mapped from YANG variable /fdu_record/image/format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_format() directly.

    YANG Description: The format of the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_format(self):
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  uri = __builtin__.property(_get_uri, _set_uri)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  format = __builtin__.property(_get_format, _set_format)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('uri', uri), ('checksum', checksum), ('format', format), ])


class yc_command_infra_fdu__fdu_record_command(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/command. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Command used for start the BARE FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__binary','__args',)

  _yang_name = 'command'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__binary = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'command']

  def _get_binary(self):
    """
    Getter method for binary, mapped from YANG variable /fdu_record/command/binary (string)

    YANG Description: Path to the binary to be started
    """
    return self.__binary
      
  def _set_binary(self, v, load=False):
    """
    Setter method for binary, mapped from YANG variable /fdu_record/command/binary (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_binary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_binary() directly.

    YANG Description: Path to the binary to be started
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """binary must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__binary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_binary(self):
    self.__binary = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /fdu_record/command/args (string)

    YANG Description: List of arguments passed to the binary
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /fdu_record/command/args (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: List of arguments passed to the binary
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  binary = __builtin__.property(_get_binary, _set_binary)
  args = __builtin__.property(_get_args, _set_args)


  _pyangbind_elements = OrderedDict([('binary', binary), ('args', args), ])


class yc_computation_requirements_infra_fdu__fdu_record_computation_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/computation_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Computation requirement for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__cpu_arch','__cpu_min_freq','__cpu_min_count','__ram_size_mb','__storage_size_gb','__gpu_min_count','__fpga_min_count','__duty_cycle',)

  _yang_name = 'computation_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__cpu_arch = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__cpu_min_freq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__cpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__ram_size_mb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    self.__storage_size_gb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    self.__gpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__fpga_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__duty_cycle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'computation_requirements']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /fdu_record/computation_requirements/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /fdu_record/computation_requirements/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_cpu_arch(self):
    """
    Getter method for cpu_arch, mapped from YANG variable /fdu_record/computation_requirements/cpu_arch (string)

    YANG Description: CPU architecture needed by this FDU
    """
    return self.__cpu_arch
      
  def _set_cpu_arch(self, v, load=False):
    """
    Setter method for cpu_arch, mapped from YANG variable /fdu_record/computation_requirements/cpu_arch (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_arch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_arch() directly.

    YANG Description: CPU architecture needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_arch must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__cpu_arch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_arch(self):
    self.__cpu_arch = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_cpu_min_freq(self):
    """
    Getter method for cpu_min_freq, mapped from YANG variable /fdu_record/computation_requirements/cpu_min_freq (int64)

    YANG Description: Minumum CPU freq needed
    """
    return self.__cpu_min_freq
      
  def _set_cpu_min_freq(self, v, load=False):
    """
    Setter method for cpu_min_freq, mapped from YANG variable /fdu_record/computation_requirements/cpu_min_freq (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_min_freq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_min_freq() directly.

    YANG Description: Minumum CPU freq needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_min_freq must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__cpu_min_freq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_min_freq(self):
    self.__cpu_min_freq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_cpu_min_count(self):
    """
    Getter method for cpu_min_count, mapped from YANG variable /fdu_record/computation_requirements/cpu_min_count (int64)

    YANG Description: Minumum number of vCPU needed
    """
    return self.__cpu_min_count
      
  def _set_cpu_min_count(self, v, load=False):
    """
    Setter method for cpu_min_count, mapped from YANG variable /fdu_record/computation_requirements/cpu_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_min_count() directly.

    YANG Description: Minumum number of vCPU needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__cpu_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_min_count(self):
    self.__cpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_ram_size_mb(self):
    """
    Getter method for ram_size_mb, mapped from YANG variable /fdu_record/computation_requirements/ram_size_mb (decimal64)

    YANG Description: RAM needed
    """
    return self.__ram_size_mb
      
  def _set_ram_size_mb(self, v, load=False):
    """
    Setter method for ram_size_mb, mapped from YANG variable /fdu_record/computation_requirements/ram_size_mb (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ram_size_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ram_size_mb() directly.

    YANG Description: RAM needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ram_size_mb must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)""",
        })

    self.__ram_size_mb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ram_size_mb(self):
    self.__ram_size_mb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)


  def _get_storage_size_gb(self):
    """
    Getter method for storage_size_gb, mapped from YANG variable /fdu_record/computation_requirements/storage_size_gb (decimal64)

    YANG Description: Root disk size needed
    """
    return self.__storage_size_gb
      
  def _set_storage_size_gb(self, v, load=False):
    """
    Setter method for storage_size_gb, mapped from YANG variable /fdu_record/computation_requirements/storage_size_gb (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_size_gb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_size_gb() directly.

    YANG Description: Root disk size needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_size_gb must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)""",
        })

    self.__storage_size_gb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_size_gb(self):
    self.__storage_size_gb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)


  def _get_gpu_min_count(self):
    """
    Getter method for gpu_min_count, mapped from YANG variable /fdu_record/computation_requirements/gpu_min_count (int64)

    YANG Description: Minumum number of GPU needed
    """
    return self.__gpu_min_count
      
  def _set_gpu_min_count(self, v, load=False):
    """
    Setter method for gpu_min_count, mapped from YANG variable /fdu_record/computation_requirements/gpu_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gpu_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gpu_min_count() directly.

    YANG Description: Minumum number of GPU needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gpu_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__gpu_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gpu_min_count(self):
    self.__gpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_fpga_min_count(self):
    """
    Getter method for fpga_min_count, mapped from YANG variable /fdu_record/computation_requirements/fpga_min_count (int64)

    YANG Description: Minimum number of FPGA needed
    """
    return self.__fpga_min_count
      
  def _set_fpga_min_count(self, v, load=False):
    """
    Setter method for fpga_min_count, mapped from YANG variable /fdu_record/computation_requirements/fpga_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fpga_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fpga_min_count() directly.

    YANG Description: Minimum number of FPGA needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fpga_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__fpga_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fpga_min_count(self):
    self.__fpga_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_duty_cycle(self):
    """
    Getter method for duty_cycle, mapped from YANG variable /fdu_record/computation_requirements/duty_cycle (decimal64)
    """
    return self.__duty_cycle
      
  def _set_duty_cycle(self, v, load=False):
    """
    Setter method for duty_cycle, mapped from YANG variable /fdu_record/computation_requirements/duty_cycle (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duty_cycle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duty_cycle() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duty_cycle must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)""",
        })

    self.__duty_cycle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duty_cycle(self):
    self.__duty_cycle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  cpu_arch = __builtin__.property(_get_cpu_arch, _set_cpu_arch)
  cpu_min_freq = __builtin__.property(_get_cpu_min_freq, _set_cpu_min_freq)
  cpu_min_count = __builtin__.property(_get_cpu_min_count, _set_cpu_min_count)
  ram_size_mb = __builtin__.property(_get_ram_size_mb, _set_ram_size_mb)
  storage_size_gb = __builtin__.property(_get_storage_size_gb, _set_storage_size_gb)
  gpu_min_count = __builtin__.property(_get_gpu_min_count, _set_gpu_min_count)
  fpga_min_count = __builtin__.property(_get_fpga_min_count, _set_fpga_min_count)
  duty_cycle = __builtin__.property(_get_duty_cycle, _set_duty_cycle)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('cpu_arch', cpu_arch), ('cpu_min_freq', cpu_min_freq), ('cpu_min_count', cpu_min_count), ('ram_size_mb', ram_size_mb), ('storage_size_gb', storage_size_gb), ('gpu_min_count', gpu_min_count), ('fpga_min_count', fpga_min_count), ('duty_cycle', duty_cycle), ])


class yc_position_infra_fdu__fdu_record_geographical_requirements_position(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/geographical_requirements/position. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Postion requirement for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__lat','__lon','__radius',)

  _yang_name = 'position'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__lon = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'geographical_requirements', 'position']

  def _get_lat(self):
    """
    Getter method for lat, mapped from YANG variable /fdu_record/geographical_requirements/position/lat (string)

    YANG Description: Latitude
    """
    return self.__lat
      
  def _set_lat(self, v, load=False):
    """
    Setter method for lat, mapped from YANG variable /fdu_record/geographical_requirements/position/lat (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lat() directly.

    YANG Description: Latitude
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lat must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__lat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lat(self):
    self.__lat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_lon(self):
    """
    Getter method for lon, mapped from YANG variable /fdu_record/geographical_requirements/position/lon (string)

    YANG Description: Longitude
    """
    return self.__lon
      
  def _set_lon(self, v, load=False):
    """
    Setter method for lon, mapped from YANG variable /fdu_record/geographical_requirements/position/lon (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lon() directly.

    YANG Description: Longitude
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lon must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__lon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lon(self):
    self.__lon = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_radius(self):
    """
    Getter method for radius, mapped from YANG variable /fdu_record/geographical_requirements/position/radius (decimal64)

    YANG Description: Radius in meter
    """
    return self.__radius
      
  def _set_radius(self, v, load=False):
    """
    Setter method for radius, mapped from YANG variable /fdu_record/geographical_requirements/position/radius (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius() directly.

    YANG Description: Radius in meter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)""",
        })

    self.__radius = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius(self):
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

  lat = __builtin__.property(_get_lat, _set_lat)
  lon = __builtin__.property(_get_lon, _set_lon)
  radius = __builtin__.property(_get_radius, _set_radius)


  _pyangbind_elements = OrderedDict([('lat', lat), ('lon', lon), ('radius', radius), ])


class yc_proximity_infra_fdu__fdu_record_geographical_requirements_proximity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/geographical_requirements/proximity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbour','__radius',)

  _yang_name = 'proximity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'geographical_requirements', 'proximity']

  def _get_neighbour(self):
    """
    Getter method for neighbour, mapped from YANG variable /fdu_record/geographical_requirements/proximity/neighbour (string)
    """
    return self.__neighbour
      
  def _set_neighbour(self, v, load=False):
    """
    Setter method for neighbour, mapped from YANG variable /fdu_record/geographical_requirements/proximity/neighbour (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbour() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbour must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__neighbour = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbour(self):
    self.__neighbour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_radius(self):
    """
    Getter method for radius, mapped from YANG variable /fdu_record/geographical_requirements/proximity/radius (decimal64)
    """
    return self.__radius
      
  def _set_radius(self, v, load=False):
    """
    Setter method for radius, mapped from YANG variable /fdu_record/geographical_requirements/proximity/radius (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)""",
        })

    self.__radius = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius(self):
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='decimal64', is_config=True)

  neighbour = __builtin__.property(_get_neighbour, _set_neighbour)
  radius = __builtin__.property(_get_radius, _set_radius)


  _pyangbind_elements = OrderedDict([('neighbour', neighbour), ('radius', radius), ])


class yc_geographical_requirements_infra_fdu__fdu_record_geographical_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/geographical_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__position','__proximity',)

  _yang_name = 'geographical_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__position = YANGDynClass(base=yc_position_infra_fdu__fdu_record_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__proximity = YANGDynClass(base=YANGListType("neighbour",yc_proximity_infra_fdu__fdu_record_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'geographical_requirements']

  def _get_position(self):
    """
    Getter method for position, mapped from YANG variable /fdu_record/geographical_requirements/position (container)

    YANG Description: Postion requirement for this FDU
    """
    return self.__position
      
  def _set_position(self, v, load=False):
    """
    Setter method for position, mapped from YANG variable /fdu_record/geographical_requirements/position (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Postion requirement for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_position_infra_fdu__fdu_record_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """position must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_position_infra_fdu__fdu_record_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_position(self):
    self.__position = YANGDynClass(base=yc_position_infra_fdu__fdu_record_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_proximity(self):
    """
    Getter method for proximity, mapped from YANG variable /fdu_record/geographical_requirements/proximity (list)
    """
    return self.__proximity
      
  def _set_proximity(self, v, load=False):
    """
    Setter method for proximity, mapped from YANG variable /fdu_record/geographical_requirements/proximity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proximity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proximity() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("neighbour",yc_proximity_infra_fdu__fdu_record_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proximity must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbour",yc_proximity_infra_fdu__fdu_record_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)""",
        })

    self.__proximity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proximity(self):
    self.__proximity = YANGDynClass(base=YANGListType("neighbour",yc_proximity_infra_fdu__fdu_record_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)

  position = __builtin__.property(_get_position, _set_position)
  proximity = __builtin__.property(_get_proximity, _set_proximity)


  _pyangbind_elements = OrderedDict([('position', position), ('proximity', proximity), ])


class yc_energy_requirements_infra_fdu__fdu_record_energy_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/energy_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key',)

  _yang_name = 'energy_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'energy_requirements']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /fdu_record/energy_requirements/key (string)
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /fdu_record/energy_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)


  _pyangbind_elements = OrderedDict([('key', key), ])


class yc_configuration_infra_fdu__fdu_record_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration script for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__conf_type','__script','__ssh_keys',)

  _yang_name = 'configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__conf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='conf_types', is_config=True)
    self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__ssh_keys = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'configuration']

  def _get_conf_type(self):
    """
    Getter method for conf_type, mapped from YANG variable /fdu_record/configuration/conf_type (conf_types)

    YANG Description: Configuration script type
    """
    return self.__conf_type
      
  def _set_conf_type(self, v, load=False):
    """
    Setter method for conf_type, mapped from YANG variable /fdu_record/configuration/conf_type (conf_types)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conf_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conf_type() directly.

    YANG Description: Configuration script type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='conf_types', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conf_type must be of a type compatible with conf_types""",
          'defined-type': "infra_fdu:conf_types",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='conf_types', is_config=True)""",
        })

    self.__conf_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conf_type(self):
    self.__conf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='conf_types', is_config=True)


  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /fdu_record/configuration/script (string)

    YANG Description: Configuration script
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /fdu_record/configuration/script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.

    YANG Description: Configuration script
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_ssh_keys(self):
    """
    Getter method for ssh_keys, mapped from YANG variable /fdu_record/configuration/ssh_keys (string)
    """
    return self.__ssh_keys
      
  def _set_ssh_keys(self, v, load=False):
    """
    Setter method for ssh_keys, mapped from YANG variable /fdu_record/configuration/ssh_keys (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_keys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_keys() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_keys must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__ssh_keys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_keys(self):
    self.__ssh_keys = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  conf_type = __builtin__.property(_get_conf_type, _set_conf_type)
  script = __builtin__.property(_get_script, _set_script)
  ssh_keys = __builtin__.property(_get_ssh_keys, _set_ssh_keys)


  _pyangbind_elements = OrderedDict([('conf_type', conf_type), ('script', script), ('ssh_keys', ssh_keys), ])


class yc_virtual_interface_infra_fdu__fdu_record_interfaces_virtual_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/interfaces/virtual_interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__intf_type','__vpci','__bandwidth',)

  _yang_name = 'virtual_interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__intf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='vintf_t', is_config=True)
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'interfaces', 'virtual_interface']

  def _get_intf_type(self):
    """
    Getter method for intf_type, mapped from YANG variable /fdu_record/interfaces/virtual_interface/intf_type (vintf_t)
    """
    return self.__intf_type
      
  def _set_intf_type(self, v, load=False):
    """
    Setter method for intf_type, mapped from YANG variable /fdu_record/interfaces/virtual_interface/intf_type (vintf_t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='vintf_t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_type must be of a type compatible with vintf_t""",
          'defined-type': "infra_fdu:vintf_t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='vintf_t', is_config=True)""",
        })

    self.__intf_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_type(self):
    self.__intf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='vintf_t', is_config=True)


  def _get_vpci(self):
    """
    Getter method for vpci, mapped from YANG variable /fdu_record/interfaces/virtual_interface/vpci (string)
    """
    return self.__vpci
      
  def _set_vpci(self, v, load=False):
    """
    Setter method for vpci, mapped from YANG variable /fdu_record/interfaces/virtual_interface/vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpci() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpci must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__vpci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpci(self):
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /fdu_record/interfaces/virtual_interface/bandwidth (int64)
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /fdu_record/interfaces/virtual_interface/bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)

  intf_type = __builtin__.property(_get_intf_type, _set_intf_type)
  vpci = __builtin__.property(_get_vpci, _set_vpci)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)


  _pyangbind_elements = OrderedDict([('intf_type', intf_type), ('vpci', vpci), ('bandwidth', bandwidth), ])


class yc_interfaces_infra_fdu__fdu_record_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of virtual intefaces used by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__is_mgmt','__if_type','__mac_address','__virtual_interface','__cp_id','__ext_cp_id','__vintf_name','__status','__phy_face','__veth_face_name','__properties',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='intf_t', is_config=True)
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_infra_fdu__fdu_record_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__ext_cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__vintf_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vintf_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CREATE': {}, 'CONNECTED': {}, 'DISCONNECTED': {}, 'DESTROY': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='net_state', is_config=True)
    self.__phy_face = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="phy_face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__veth_face_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__properties = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'interfaces']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /fdu_record/interfaces/name (string)

    YANG Description: Name of the virtual int64eface
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /fdu_record/interfaces/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the virtual int64eface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_is_mgmt(self):
    """
    Getter method for is_mgmt, mapped from YANG variable /fdu_record/interfaces/is_mgmt (boolean)

    YANG Description: True if the int64erface is a management one
    """
    return self.__is_mgmt
      
  def _set_is_mgmt(self, v, load=False):
    """
    Setter method for is_mgmt, mapped from YANG variable /fdu_record/interfaces/is_mgmt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mgmt() directly.

    YANG Description: True if the int64erface is a management one
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mgmt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)""",
        })

    self.__is_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mgmt(self):
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)


  def _get_if_type(self):
    """
    Getter method for if_type, mapped from YANG variable /fdu_record/interfaces/if_type (intf_t)

    YANG Description: Type of the virtualised interface
    """
    return self.__if_type
      
  def _set_if_type(self, v, load=False):
    """
    Setter method for if_type, mapped from YANG variable /fdu_record/interfaces/if_type (intf_t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_type() directly.

    YANG Description: Type of the virtualised interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='intf_t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_type must be of a type compatible with intf_t""",
          'defined-type': "infra_fdu:intf_t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='intf_t', is_config=True)""",
        })

    self.__if_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_type(self):
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='intf_t', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /fdu_record/interfaces/mac_address (string)

    YANG Description: MAC Address of the int64erface (AA:BB:CC:DD:EE:FF)
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /fdu_record/interfaces/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC Address of the int64erface (AA:BB:CC:DD:EE:FF)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_virtual_interface(self):
    """
    Getter method for virtual_interface, mapped from YANG variable /fdu_record/interfaces/virtual_interface (container)
    """
    return self.__virtual_interface
      
  def _set_virtual_interface(self, v, load=False):
    """
    Setter method for virtual_interface, mapped from YANG variable /fdu_record/interfaces/virtual_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_interface_infra_fdu__fdu_record_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_interface_infra_fdu__fdu_record_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__virtual_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_interface(self):
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_infra_fdu__fdu_record_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /fdu_record/interfaces/cp_id (string)

    YANG Description: Reference to an internal connection point connected to this interface
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /fdu_record/interfaces/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.

    YANG Description: Reference to an internal connection point connected to this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_ext_cp_id(self):
    """
    Getter method for ext_cp_id, mapped from YANG variable /fdu_record/interfaces/ext_cp_id (string)
    """
    return self.__ext_cp_id
      
  def _set_ext_cp_id(self, v, load=False):
    """
    Setter method for ext_cp_id, mapped from YANG variable /fdu_record/interfaces/ext_cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__ext_cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_cp_id(self):
    self.__ext_cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_vintf_name(self):
    """
    Getter method for vintf_name, mapped from YANG variable /fdu_record/interfaces/vintf_name (string)
    """
    return self.__vintf_name
      
  def _set_vintf_name(self, v, load=False):
    """
    Setter method for vintf_name, mapped from YANG variable /fdu_record/interfaces/vintf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vintf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vintf_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vintf_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vintf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vintf_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__vintf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vintf_name(self):
    self.__vintf_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vintf_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /fdu_record/interfaces/status (net_state)
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /fdu_record/interfaces/status (net_state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CREATE': {}, 'CONNECTED': {}, 'DISCONNECTED': {}, 'DESTROY': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='net_state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with net_state""",
          'defined-type': "infra_fdu:net_state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CREATE': {}, 'CONNECTED': {}, 'DISCONNECTED': {}, 'DESTROY': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='net_state', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CREATE': {}, 'CONNECTED': {}, 'DISCONNECTED': {}, 'DESTROY': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='net_state', is_config=True)


  def _get_phy_face(self):
    """
    Getter method for phy_face, mapped from YANG variable /fdu_record/interfaces/phy_face (string)
    """
    return self.__phy_face
      
  def _set_phy_face(self, v, load=False):
    """
    Setter method for phy_face, mapped from YANG variable /fdu_record/interfaces/phy_face (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phy_face is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phy_face() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="phy_face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phy_face must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="phy_face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__phy_face = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phy_face(self):
    self.__phy_face = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="phy_face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_veth_face_name(self):
    """
    Getter method for veth_face_name, mapped from YANG variable /fdu_record/interfaces/veth_face_name (string)
    """
    return self.__veth_face_name
      
  def _set_veth_face_name(self, v, load=False):
    """
    Setter method for veth_face_name, mapped from YANG variable /fdu_record/interfaces/veth_face_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_veth_face_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_veth_face_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """veth_face_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__veth_face_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_veth_face_name(self):
    self.__veth_face_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_properties(self):
    """
    Getter method for properties, mapped from YANG variable /fdu_record/interfaces/properties (string)
    """
    return self.__properties
      
  def _set_properties(self, v, load=False):
    """
    Setter method for properties, mapped from YANG variable /fdu_record/interfaces/properties (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_properties() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """properties must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_properties(self):
    self.__properties = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  is_mgmt = __builtin__.property(_get_is_mgmt, _set_is_mgmt)
  if_type = __builtin__.property(_get_if_type, _set_if_type)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  virtual_interface = __builtin__.property(_get_virtual_interface, _set_virtual_interface)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)
  ext_cp_id = __builtin__.property(_get_ext_cp_id, _set_ext_cp_id)
  vintf_name = __builtin__.property(_get_vintf_name, _set_vintf_name)
  status = __builtin__.property(_get_status, _set_status)
  phy_face = __builtin__.property(_get_phy_face, _set_phy_face)
  veth_face_name = __builtin__.property(_get_veth_face_name, _set_veth_face_name)
  properties = __builtin__.property(_get_properties, _set_properties)


  _pyangbind_elements = OrderedDict([('name', name), ('is_mgmt', is_mgmt), ('if_type', if_type), ('mac_address', mac_address), ('virtual_interface', virtual_interface), ('cp_id', cp_id), ('ext_cp_id', ext_cp_id), ('vintf_name', vintf_name), ('status', status), ('phy_face', phy_face), ('veth_face_name', veth_face_name), ('properties', properties), ])


class yc_storage_infra_fdu__fdu_record_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__storage_id','__storage_type','__size','__file_system_protocol','__cp_id',)

  _yang_name = 'storage'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__storage_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="storage_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__storage_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='storage_kind', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__file_system_protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'storage']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /fdu_record/storage/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /fdu_record/storage/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_storage_id(self):
    """
    Getter method for storage_id, mapped from YANG variable /fdu_record/storage/storage_id (string)
    """
    return self.__storage_id
      
  def _set_storage_id(self, v, load=False):
    """
    Setter method for storage_id, mapped from YANG variable /fdu_record/storage/storage_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="storage_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="storage_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__storage_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_id(self):
    self.__storage_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="storage_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_storage_type(self):
    """
    Getter method for storage_type, mapped from YANG variable /fdu_record/storage/storage_type (storage_kind)
    """
    return self.__storage_type
      
  def _set_storage_type(self, v, load=False):
    """
    Setter method for storage_type, mapped from YANG variable /fdu_record/storage/storage_type (storage_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='storage_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_type must be of a type compatible with storage_kind""",
          'defined-type': "infra_fdu:storage_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='storage_kind', is_config=True)""",
        })

    self.__storage_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_type(self):
    self.__storage_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='storage_kind', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /fdu_record/storage/size (int64)
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /fdu_record/storage/size (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_file_system_protocol(self):
    """
    Getter method for file_system_protocol, mapped from YANG variable /fdu_record/storage/file_system_protocol (string)
    """
    return self.__file_system_protocol
      
  def _set_file_system_protocol(self, v, load=False):
    """
    Setter method for file_system_protocol, mapped from YANG variable /fdu_record/storage/file_system_protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file_system_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file_system_protocol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file_system_protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__file_system_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file_system_protocol(self):
    self.__file_system_protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /fdu_record/storage/cp_id (string)
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /fdu_record/storage/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  storage_id = __builtin__.property(_get_storage_id, _set_storage_id)
  storage_type = __builtin__.property(_get_storage_type, _set_storage_type)
  size = __builtin__.property(_get_size, _set_size)
  file_system_protocol = __builtin__.property(_get_file_system_protocol, _set_file_system_protocol)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('storage_id', storage_id), ('storage_type', storage_type), ('size', size), ('file_system_protocol', file_system_protocol), ('cp_id', cp_id), ])


class yc_connection_points_infra_fdu__fdu_record_connection_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/connection_points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Internal connection points definited by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__cp_id','__cp_type','__port_security_enabled','__vld_ref','__veth_face_name','__br_name','__properties','__status',)

  _yang_name = 'connection_points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='cp_kind', is_config=True)
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__veth_face_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__br_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="br_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__properties = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'connection_points']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /fdu_record/connection_points/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /fdu_record/connection_points/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /fdu_record/connection_points/cp_id (string)
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /fdu_record/connection_points/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_cp_type(self):
    """
    Getter method for cp_type, mapped from YANG variable /fdu_record/connection_points/cp_type (cp_kind)
    """
    return self.__cp_type
      
  def _set_cp_type(self, v, load=False):
    """
    Setter method for cp_type, mapped from YANG variable /fdu_record/connection_points/cp_type (cp_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='cp_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_type must be of a type compatible with cp_kind""",
          'defined-type': "infra_fdu:cp_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='cp_kind', is_config=True)""",
        })

    self.__cp_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_type(self):
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='cp_kind', is_config=True)


  def _get_port_security_enabled(self):
    """
    Getter method for port_security_enabled, mapped from YANG variable /fdu_record/connection_points/port_security_enabled (boolean)
    """
    return self.__port_security_enabled
      
  def _set_port_security_enabled(self, v, load=False):
    """
    Setter method for port_security_enabled, mapped from YANG variable /fdu_record/connection_points/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)""",
        })

    self.__port_security_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security_enabled(self):
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='boolean', is_config=True)


  def _get_vld_ref(self):
    """
    Getter method for vld_ref, mapped from YANG variable /fdu_record/connection_points/vld_ref (string)

    YANG Description: Reference to the VL this CP is connected
    """
    return self.__vld_ref
      
  def _set_vld_ref(self, v, load=False):
    """
    Setter method for vld_ref, mapped from YANG variable /fdu_record/connection_points/vld_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld_ref() directly.

    YANG Description: Reference to the VL this CP is connected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__vld_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld_ref(self):
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_veth_face_name(self):
    """
    Getter method for veth_face_name, mapped from YANG variable /fdu_record/connection_points/veth_face_name (string)
    """
    return self.__veth_face_name
      
  def _set_veth_face_name(self, v, load=False):
    """
    Setter method for veth_face_name, mapped from YANG variable /fdu_record/connection_points/veth_face_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_veth_face_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_veth_face_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """veth_face_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__veth_face_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_veth_face_name(self):
    self.__veth_face_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="veth_face_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_br_name(self):
    """
    Getter method for br_name, mapped from YANG variable /fdu_record/connection_points/br_name (string)
    """
    return self.__br_name
      
  def _set_br_name(self, v, load=False):
    """
    Setter method for br_name, mapped from YANG variable /fdu_record/connection_points/br_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_br_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_br_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="br_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """br_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="br_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__br_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_br_name(self):
    self.__br_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="br_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_properties(self):
    """
    Getter method for properties, mapped from YANG variable /fdu_record/connection_points/properties (string)
    """
    return self.__properties
      
  def _set_properties(self, v, load=False):
    """
    Setter method for properties, mapped from YANG variable /fdu_record/connection_points/properties (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_properties() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """properties must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_properties(self):
    self.__properties = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /fdu_record/connection_points/status (string)
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /fdu_record/connection_points/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)
  cp_type = __builtin__.property(_get_cp_type, _set_cp_type)
  port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
  vld_ref = __builtin__.property(_get_vld_ref, _set_vld_ref)
  veth_face_name = __builtin__.property(_get_veth_face_name, _set_veth_face_name)
  br_name = __builtin__.property(_get_br_name, _set_br_name)
  properties = __builtin__.property(_get_properties, _set_properties)
  status = __builtin__.property(_get_status, _set_status)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('cp_id', cp_id), ('cp_type', cp_type), ('port_security_enabled', port_security_enabled), ('vld_ref', vld_ref), ('veth_face_name', veth_face_name), ('br_name', br_name), ('properties', properties), ('status', status), ])


class yc_io_ports_infra_fdu__fdu_record_io_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/io_ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: I/O ports needed by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__min_io_ports','__io_type',)

  _yang_name = 'io_ports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__min_io_ports = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__io_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='io_kind', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'io_ports']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /fdu_record/io_ports/name (string)

    YANG Description: Name of the IO port
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /fdu_record/io_ports/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IO port
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_min_io_ports(self):
    """
    Getter method for min_io_ports, mapped from YANG variable /fdu_record/io_ports/min_io_ports (int64)

    YANG Description: Minumum number of IO ports needed
    """
    return self.__min_io_ports
      
  def _set_min_io_ports(self, v, load=False):
    """
    Setter method for min_io_ports, mapped from YANG variable /fdu_record/io_ports/min_io_ports (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_io_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_io_ports() directly.

    YANG Description: Minumum number of IO ports needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_io_ports must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__min_io_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_io_ports(self):
    self.__min_io_ports = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_io_type(self):
    """
    Getter method for io_type, mapped from YANG variable /fdu_record/io_ports/io_type (io_kind)

    YANG Description: Type of the IO ports
    """
    return self.__io_type
      
  def _set_io_type(self, v, load=False):
    """
    Setter method for io_type, mapped from YANG variable /fdu_record/io_ports/io_type (io_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_io_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_io_type() directly.

    YANG Description: Type of the IO ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='io_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """io_type must be of a type compatible with io_kind""",
          'defined-type': "infra_fdu:io_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='io_kind', is_config=True)""",
        })

    self.__io_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_io_type(self):
    self.__io_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='io_kind', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  min_io_ports = __builtin__.property(_get_min_io_ports, _set_min_io_ports)
  io_type = __builtin__.property(_get_io_type, _set_io_type)


  _pyangbind_elements = OrderedDict([('name', name), ('min_io_ports', min_io_ports), ('io_type', io_type), ])


class yc_migration_properties_infra_fdu__fdu_record_migration_properties(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record/migration_properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__destination','__source',)

  _yang_name = 'migration_properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__destination = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__source = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record', 'migration_properties']

  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /fdu_record/migration_properties/destination (string)
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /fdu_record/migration_properties/destination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /fdu_record/migration_properties/source (string)
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /fdu_record/migration_properties/source (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  destination = __builtin__.property(_get_destination, _set_destination)
  source = __builtin__.property(_get_source, _set_source)


  _pyangbind_elements = OrderedDict([('destination', destination), ('source', source), ])


class yc_fdu_record_infra_fdu__fdu_record(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /fdu_record. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__fdu_id','__status','__image','__command','__computation_requirements','__geographical_requirements','__energy_requirements','__configuration','__interfaces','__storage','__hypervisor','__migration_kind','__connection_points','__io_ports','__depends_on','__error_code','__error_msg','__migration_properties','__hypervisor_info',)

  _yang_name = 'fdu_record'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__fdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fdu_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DEFINE': {}, 'CONFIGURE': {}, 'CLEAN': {}, 'RUN': {}, 'STARTING': {}, 'STOP': {}, 'RESUME': {}, 'PAUSE': {}, 'SCALE': {}, 'TAKE_OFF': {}, 'LAND': {}, 'MIGRATE': {}, 'UNDEFINE': {}, 'ERROR': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='fdu_state', is_config=True)
    self.__image = YANGDynClass(base=yc_image_infra_fdu__fdu_record_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__command = YANGDynClass(base=yc_command_infra_fdu__fdu_record_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__computation_requirements = YANGDynClass(base=yc_computation_requirements_infra_fdu__fdu_record_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__geographical_requirements = YANGDynClass(base=yc_geographical_requirements_infra_fdu__fdu_record_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__energy_requirements = YANGDynClass(base=yc_energy_requirements_infra_fdu__fdu_record_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__configuration = YANGDynClass(base=yc_configuration_infra_fdu__fdu_record_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=YANGListType("name",yc_interfaces_infra_fdu__fdu_record_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    self.__storage = YANGDynClass(base=YANGListType("uuid",yc_storage_infra_fdu__fdu_record_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    self.__hypervisor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='hv_kind', is_config=True)
    self.__migration_kind = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='migr_kind', is_config=True)
    self.__connection_points = YANGDynClass(base=YANGListType("uuid",yc_connection_points_infra_fdu__fdu_record_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    self.__io_ports = YANGDynClass(base=YANGListType("name",yc_io_ports_infra_fdu__fdu_record_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__error_code = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="error_code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    self.__error_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error_msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    self.__migration_properties = YANGDynClass(base=yc_migration_properties_infra_fdu__fdu_record_migration_properties, is_container='container', yang_name="migration_properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    self.__hypervisor_info = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hypervisor_info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['fdu_record']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /fdu_record/uuid (string)

    YANG Description: UUID of the FDU Instance
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /fdu_record/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: UUID of the FDU Instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_fdu_id(self):
    """
    Getter method for fdu_id, mapped from YANG variable /fdu_record/fdu_id (string)

    YANG Description: Reference to the FDU descriptor
    """
    return self.__fdu_id
      
  def _set_fdu_id(self, v, load=False):
    """
    Setter method for fdu_id, mapped from YANG variable /fdu_record/fdu_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fdu_id() directly.

    YANG Description: Reference to the FDU descriptor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="fdu_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fdu_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fdu_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__fdu_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fdu_id(self):
    self.__fdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fdu_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /fdu_record/status (fdu_state)
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /fdu_record/status (fdu_state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DEFINE': {}, 'CONFIGURE': {}, 'CLEAN': {}, 'RUN': {}, 'STARTING': {}, 'STOP': {}, 'RESUME': {}, 'PAUSE': {}, 'SCALE': {}, 'TAKE_OFF': {}, 'LAND': {}, 'MIGRATE': {}, 'UNDEFINE': {}, 'ERROR': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='fdu_state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with fdu_state""",
          'defined-type': "infra_fdu:fdu_state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DEFINE': {}, 'CONFIGURE': {}, 'CLEAN': {}, 'RUN': {}, 'STARTING': {}, 'STOP': {}, 'RESUME': {}, 'PAUSE': {}, 'SCALE': {}, 'TAKE_OFF': {}, 'LAND': {}, 'MIGRATE': {}, 'UNDEFINE': {}, 'ERROR': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='fdu_state', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DEFINE': {}, 'CONFIGURE': {}, 'CLEAN': {}, 'RUN': {}, 'STARTING': {}, 'STOP': {}, 'RESUME': {}, 'PAUSE': {}, 'SCALE': {}, 'TAKE_OFF': {}, 'LAND': {}, 'MIGRATE': {}, 'UNDEFINE': {}, 'ERROR': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='fdu_state', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /fdu_record/image (container)

    YANG Description: Imange used when instatiating the FDU
    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /fdu_record/image (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Imange used when instatiating the FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_image_infra_fdu__fdu_record_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_image_infra_fdu__fdu_record_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=yc_image_infra_fdu__fdu_record_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_command(self):
    """
    Getter method for command, mapped from YANG variable /fdu_record/command (container)

    YANG Description: Command used for start the BARE FDU
    """
    return self.__command
      
  def _set_command(self, v, load=False):
    """
    Setter method for command, mapped from YANG variable /fdu_record/command (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_command is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_command() directly.

    YANG Description: Command used for start the BARE FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_command_infra_fdu__fdu_record_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """command must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_command_infra_fdu__fdu_record_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__command = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_command(self):
    self.__command = YANGDynClass(base=yc_command_infra_fdu__fdu_record_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_computation_requirements(self):
    """
    Getter method for computation_requirements, mapped from YANG variable /fdu_record/computation_requirements (container)

    YANG Description: Computation requirement for this FDU
    """
    return self.__computation_requirements
      
  def _set_computation_requirements(self, v, load=False):
    """
    Setter method for computation_requirements, mapped from YANG variable /fdu_record/computation_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_computation_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_computation_requirements() directly.

    YANG Description: Computation requirement for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_computation_requirements_infra_fdu__fdu_record_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """computation_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_computation_requirements_infra_fdu__fdu_record_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__computation_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_computation_requirements(self):
    self.__computation_requirements = YANGDynClass(base=yc_computation_requirements_infra_fdu__fdu_record_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_geographical_requirements(self):
    """
    Getter method for geographical_requirements, mapped from YANG variable /fdu_record/geographical_requirements (container)
    """
    return self.__geographical_requirements
      
  def _set_geographical_requirements(self, v, load=False):
    """
    Setter method for geographical_requirements, mapped from YANG variable /fdu_record/geographical_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geographical_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geographical_requirements() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_geographical_requirements_infra_fdu__fdu_record_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geographical_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_geographical_requirements_infra_fdu__fdu_record_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__geographical_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geographical_requirements(self):
    self.__geographical_requirements = YANGDynClass(base=yc_geographical_requirements_infra_fdu__fdu_record_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_energy_requirements(self):
    """
    Getter method for energy_requirements, mapped from YANG variable /fdu_record/energy_requirements (container)
    """
    return self.__energy_requirements
      
  def _set_energy_requirements(self, v, load=False):
    """
    Setter method for energy_requirements, mapped from YANG variable /fdu_record/energy_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_energy_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_energy_requirements() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_energy_requirements_infra_fdu__fdu_record_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """energy_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_energy_requirements_infra_fdu__fdu_record_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__energy_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_energy_requirements(self):
    self.__energy_requirements = YANGDynClass(base=yc_energy_requirements_infra_fdu__fdu_record_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_configuration(self):
    """
    Getter method for configuration, mapped from YANG variable /fdu_record/configuration (container)

    YANG Description: Configuration script for this FDU
    """
    return self.__configuration
      
  def _set_configuration(self, v, load=False):
    """
    Setter method for configuration, mapped from YANG variable /fdu_record/configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configuration() directly.

    YANG Description: Configuration script for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_configuration_infra_fdu__fdu_record_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_configuration_infra_fdu__fdu_record_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configuration(self):
    self.__configuration = YANGDynClass(base=yc_configuration_infra_fdu__fdu_record_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /fdu_record/interfaces (list)

    YANG Description: List of virtual intefaces used by this FDU
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /fdu_record/interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of virtual intefaces used by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interfaces_infra_fdu__fdu_record_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interfaces_infra_fdu__fdu_record_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=YANGListType("name",yc_interfaces_infra_fdu__fdu_record_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /fdu_record/storage (list)
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /fdu_record/storage (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_storage_infra_fdu__fdu_record_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_storage_infra_fdu__fdu_record_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=YANGListType("uuid",yc_storage_infra_fdu__fdu_record_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)


  def _get_hypervisor(self):
    """
    Getter method for hypervisor, mapped from YANG variable /fdu_record/hypervisor (hv_kind)

    YANG Description: Type of hypervisor needed by this FDU
    """
    return self.__hypervisor
      
  def _set_hypervisor(self, v, load=False):
    """
    Setter method for hypervisor, mapped from YANG variable /fdu_record/hypervisor (hv_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hypervisor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hypervisor() directly.

    YANG Description: Type of hypervisor needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='hv_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hypervisor must be of a type compatible with hv_kind""",
          'defined-type': "infra_fdu:hv_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='hv_kind', is_config=True)""",
        })

    self.__hypervisor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hypervisor(self):
    self.__hypervisor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='hv_kind', is_config=True)


  def _get_migration_kind(self):
    """
    Getter method for migration_kind, mapped from YANG variable /fdu_record/migration_kind (migr_kind)

    YANG Description: Kind of migration supported by the FDU
    """
    return self.__migration_kind
      
  def _set_migration_kind(self, v, load=False):
    """
    Setter method for migration_kind, mapped from YANG variable /fdu_record/migration_kind (migr_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migration_kind is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migration_kind() directly.

    YANG Description: Kind of migration supported by the FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='migr_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migration_kind must be of a type compatible with migr_kind""",
          'defined-type': "infra_fdu:migr_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='migr_kind', is_config=True)""",
        })

    self.__migration_kind = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migration_kind(self):
    self.__migration_kind = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='migr_kind', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /fdu_record/connection_points (list)

    YANG Description: Internal connection points definited by this FDU
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /fdu_record/connection_points (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: Internal connection points definited by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_connection_points_infra_fdu__fdu_record_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_connection_points_infra_fdu__fdu_record_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=YANGListType("uuid",yc_connection_points_infra_fdu__fdu_record_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)


  def _get_io_ports(self):
    """
    Getter method for io_ports, mapped from YANG variable /fdu_record/io_ports (list)

    YANG Description: I/O ports needed by this FDU
    """
    return self.__io_ports
      
  def _set_io_ports(self, v, load=False):
    """
    Setter method for io_ports, mapped from YANG variable /fdu_record/io_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_io_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_io_ports() directly.

    YANG Description: I/O ports needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_io_ports_infra_fdu__fdu_record_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """io_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_io_ports_infra_fdu__fdu_record_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)""",
        })

    self.__io_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_io_ports(self):
    self.__io_ports = YANGDynClass(base=YANGListType("name",yc_io_ports_infra_fdu__fdu_record_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='list', is_config=True)


  def _get_depends_on(self):
    """
    Getter method for depends_on, mapped from YANG variable /fdu_record/depends_on (string)
    """
    return self.__depends_on
      
  def _set_depends_on(self, v, load=False):
    """
    Setter method for depends_on, mapped from YANG variable /fdu_record/depends_on (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depends_on is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depends_on() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depends_on must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__depends_on = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depends_on(self):
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_error_code(self):
    """
    Getter method for error_code, mapped from YANG variable /fdu_record/error_code (int64)
    """
    return self.__error_code
      
  def _set_error_code(self, v, load=False):
    """
    Setter method for error_code, mapped from YANG variable /fdu_record/error_code (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_code() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="error_code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_code must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="error_code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)""",
        })

    self.__error_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_code(self):
    self.__error_code = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="error_code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='int64', is_config=True)


  def _get_error_msg(self):
    """
    Getter method for error_msg, mapped from YANG variable /fdu_record/error_msg (string)
    """
    return self.__error_msg
      
  def _set_error_msg(self, v, load=False):
    """
    Setter method for error_msg, mapped from YANG variable /fdu_record/error_msg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_msg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_msg() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="error_msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_msg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error_msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__error_msg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_msg(self):
    self.__error_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error_msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)


  def _get_migration_properties(self):
    """
    Getter method for migration_properties, mapped from YANG variable /fdu_record/migration_properties (container)
    """
    return self.__migration_properties
      
  def _set_migration_properties(self, v, load=False):
    """
    Setter method for migration_properties, mapped from YANG variable /fdu_record/migration_properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migration_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migration_properties() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_migration_properties_infra_fdu__fdu_record_migration_properties, is_container='container', yang_name="migration_properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migration_properties must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_migration_properties_infra_fdu__fdu_record_migration_properties, is_container='container', yang_name="migration_properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__migration_properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migration_properties(self):
    self.__migration_properties = YANGDynClass(base=yc_migration_properties_infra_fdu__fdu_record_migration_properties, is_container='container', yang_name="migration_properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)


  def _get_hypervisor_info(self):
    """
    Getter method for hypervisor_info, mapped from YANG variable /fdu_record/hypervisor_info (string)
    """
    return self.__hypervisor_info
      
  def _set_hypervisor_info(self, v, load=False):
    """
    Setter method for hypervisor_info, mapped from YANG variable /fdu_record/hypervisor_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hypervisor_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hypervisor_info() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hypervisor_info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hypervisor_info must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hypervisor_info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)""",
        })

    self.__hypervisor_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hypervisor_info(self):
    self.__hypervisor_info = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hypervisor_info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  fdu_id = __builtin__.property(_get_fdu_id, _set_fdu_id)
  status = __builtin__.property(_get_status, _set_status)
  image = __builtin__.property(_get_image, _set_image)
  command = __builtin__.property(_get_command, _set_command)
  computation_requirements = __builtin__.property(_get_computation_requirements, _set_computation_requirements)
  geographical_requirements = __builtin__.property(_get_geographical_requirements, _set_geographical_requirements)
  energy_requirements = __builtin__.property(_get_energy_requirements, _set_energy_requirements)
  configuration = __builtin__.property(_get_configuration, _set_configuration)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  storage = __builtin__.property(_get_storage, _set_storage)
  hypervisor = __builtin__.property(_get_hypervisor, _set_hypervisor)
  migration_kind = __builtin__.property(_get_migration_kind, _set_migration_kind)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  io_ports = __builtin__.property(_get_io_ports, _set_io_ports)
  depends_on = __builtin__.property(_get_depends_on, _set_depends_on)
  error_code = __builtin__.property(_get_error_code, _set_error_code)
  error_msg = __builtin__.property(_get_error_msg, _set_error_msg)
  migration_properties = __builtin__.property(_get_migration_properties, _set_migration_properties)
  hypervisor_info = __builtin__.property(_get_hypervisor_info, _set_hypervisor_info)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('fdu_id', fdu_id), ('status', status), ('image', image), ('command', command), ('computation_requirements', computation_requirements), ('geographical_requirements', geographical_requirements), ('energy_requirements', energy_requirements), ('configuration', configuration), ('interfaces', interfaces), ('storage', storage), ('hypervisor', hypervisor), ('migration_kind', migration_kind), ('connection_points', connection_points), ('io_ports', io_ports), ('depends_on', depends_on), ('error_code', error_code), ('error_msg', error_msg), ('migration_properties', migration_properties), ('hypervisor_info', hypervisor_info), ])


class infra_fdu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_fdu - based on the path /infra_fdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__fdu_record',)

  _yang_name = 'infra_fdu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fdu_record = YANGDynClass(base=yc_fdu_record_infra_fdu__fdu_record, is_container='container', yang_name="fdu_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_fdu_record(self):
    """
    Getter method for fdu_record, mapped from YANG variable /fdu_record (container)
    """
    return self.__fdu_record
      
  def _set_fdu_record(self, v, load=False):
    """
    Setter method for fdu_record, mapped from YANG variable /fdu_record (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fdu_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fdu_record() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fdu_record_infra_fdu__fdu_record, is_container='container', yang_name="fdu_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fdu_record must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fdu_record_infra_fdu__fdu_record, is_container='container', yang_name="fdu_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)""",
        })

    self.__fdu_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fdu_record(self):
    self.__fdu_record = YANGDynClass(base=yc_fdu_record_infra_fdu__fdu_record, is_container='container', yang_name="fdu_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:fdu', defining_module='infra_fdu', yang_type='container', is_config=True)

  fdu_record = __builtin__.property(_get_fdu_record, _set_fdu_record)


  _pyangbind_elements = OrderedDict([('fdu_record', fdu_record), ])


