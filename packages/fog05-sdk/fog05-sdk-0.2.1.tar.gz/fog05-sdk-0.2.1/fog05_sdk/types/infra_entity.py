# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_atomic_entities_infra_entity__entity_record_atomic_entities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /entity_record/atomic_entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__id','__index',)

  _yang_name = 'atomic_entities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_record', 'atomic_entities']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /entity_record/atomic_entities/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /entity_record/atomic_entities/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /entity_record/atomic_entities/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /entity_record/atomic_entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /entity_record/atomic_entities/index (int64)
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /entity_record/atomic_entities/index (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  id = __builtin__.property(_get_id, _set_id)
  index = __builtin__.property(_get_index, _set_index)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('id', id), ('index', index), ])


class yc_cps_infra_entity__entity_record_virtual_links_cps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /entity_record/virtual_links/cps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component_id_ref','__component_index_ref','__uuid','__cp_id','__has_floating_ip','__floating_ip_id','__floating_ip',)

  _yang_name = 'cps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__component_index_ref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__has_floating_ip = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    self.__floating_ip_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__floating_ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_record', 'virtual_links', 'cps']

  def _get_component_id_ref(self):
    """
    Getter method for component_id_ref, mapped from YANG variable /entity_record/virtual_links/cps/component_id_ref (string)
    """
    return self.__component_id_ref
      
  def _set_component_id_ref(self, v, load=False):
    """
    Setter method for component_id_ref, mapped from YANG variable /entity_record/virtual_links/cps/component_id_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_id_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_id_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__component_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_id_ref(self):
    self.__component_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_component_index_ref(self):
    """
    Getter method for component_index_ref, mapped from YANG variable /entity_record/virtual_links/cps/component_index_ref (int64)
    """
    return self.__component_index_ref
      
  def _set_component_index_ref(self, v, load=False):
    """
    Setter method for component_index_ref, mapped from YANG variable /entity_record/virtual_links/cps/component_index_ref (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_index_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_index_ref must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)""",
        })

    self.__component_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_index_ref(self):
    self.__component_index_ref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)


  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /entity_record/virtual_links/cps/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /entity_record/virtual_links/cps/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /entity_record/virtual_links/cps/cp_id (string)
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /entity_record/virtual_links/cps/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_has_floating_ip(self):
    """
    Getter method for has_floating_ip, mapped from YANG variable /entity_record/virtual_links/cps/has_floating_ip (boolean)
    """
    return self.__has_floating_ip
      
  def _set_has_floating_ip(self, v, load=False):
    """
    Setter method for has_floating_ip, mapped from YANG variable /entity_record/virtual_links/cps/has_floating_ip (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_has_floating_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_has_floating_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """has_floating_ip must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)""",
        })

    self.__has_floating_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_has_floating_ip(self):
    self.__has_floating_ip = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)


  def _get_floating_ip_id(self):
    """
    Getter method for floating_ip_id, mapped from YANG variable /entity_record/virtual_links/cps/floating_ip_id (string)
    """
    return self.__floating_ip_id
      
  def _set_floating_ip_id(self, v, load=False):
    """
    Setter method for floating_ip_id, mapped from YANG variable /entity_record/virtual_links/cps/floating_ip_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="floating_ip_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__floating_ip_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip_id(self):
    self.__floating_ip_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_floating_ip(self):
    """
    Getter method for floating_ip, mapped from YANG variable /entity_record/virtual_links/cps/floating_ip (string)
    """
    return self.__floating_ip
      
  def _set_floating_ip(self, v, load=False):
    """
    Setter method for floating_ip, mapped from YANG variable /entity_record/virtual_links/cps/floating_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__floating_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip(self):
    self.__floating_ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

  component_id_ref = __builtin__.property(_get_component_id_ref, _set_component_id_ref)
  component_index_ref = __builtin__.property(_get_component_index_ref, _set_component_index_ref)
  uuid = __builtin__.property(_get_uuid, _set_uuid)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)
  has_floating_ip = __builtin__.property(_get_has_floating_ip, _set_has_floating_ip)
  floating_ip_id = __builtin__.property(_get_floating_ip_id, _set_floating_ip_id)
  floating_ip = __builtin__.property(_get_floating_ip, _set_floating_ip)


  _pyangbind_elements = OrderedDict([('component_id_ref', component_id_ref), ('component_index_ref', component_index_ref), ('uuid', uuid), ('cp_id', cp_id), ('has_floating_ip', has_floating_ip), ('floating_ip_id', floating_ip_id), ('floating_ip', floating_ip), ])


class yc_ip_configuration_infra_entity__entity_record_virtual_links_ip_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /entity_record/virtual_links/ip_configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet','__gateway','__checksum','__dhcp_enable','__dhcp_range','__dns',)

  _yang_name = 'ip_configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='ip_kind', is_config=True)
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_record', 'virtual_links', 'ip_configuration']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /entity_record/virtual_links/ip_configuration/ip_version (ip_kind)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /entity_record/virtual_links/ip_configuration/ip_version (ip_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='ip_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with ip_kind""",
          'defined-type': "infra_entity:ip_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='ip_kind', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='ip_kind', is_config=True)


  def _get_subnet(self):
    """
    Getter method for subnet, mapped from YANG variable /entity_record/virtual_links/ip_configuration/subnet (string)
    """
    return self.__subnet
      
  def _set_subnet(self, v, load=False):
    """
    Setter method for subnet, mapped from YANG variable /entity_record/virtual_links/ip_configuration/subnet (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__subnet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet(self):
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /entity_record/virtual_links/ip_configuration/gateway (string)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /entity_record/virtual_links/ip_configuration/gateway (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /entity_record/virtual_links/ip_configuration/checksum (string)

    YANG Description: SHA1 checksum of the image file
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /entity_record/virtual_links/ip_configuration/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: SHA1 checksum of the image file
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_dhcp_enable(self):
    """
    Getter method for dhcp_enable, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dhcp_enable (boolean)
    """
    return self.__dhcp_enable
      
  def _set_dhcp_enable(self, v, load=False):
    """
    Setter method for dhcp_enable, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dhcp_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_enable(self):
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)


  def _get_dhcp_range(self):
    """
    Getter method for dhcp_range, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dhcp_range (string)
    """
    return self.__dhcp_range
      
  def _set_dhcp_range(self, v, load=False):
    """
    Setter method for dhcp_range, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dhcp_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_range() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__dhcp_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_range(self):
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dns (string)
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /entity_record/virtual_links/ip_configuration/dns (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet = __builtin__.property(_get_subnet, _set_subnet)
  gateway = __builtin__.property(_get_gateway, _set_gateway)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  dhcp_enable = __builtin__.property(_get_dhcp_enable, _set_dhcp_enable)
  dhcp_range = __builtin__.property(_get_dhcp_range, _set_dhcp_range)
  dns = __builtin__.property(_get_dns, _set_dns)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet', subnet), ('gateway', gateway), ('checksum', checksum), ('dhcp_enable', dhcp_enable), ('dhcp_range', dhcp_range), ('dns', dns), ])


class yc_virtual_links_infra_entity__entity_record_virtual_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /entity_record/virtual_links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vl_id','__uuid','__is_mgmt','__vl_type','__root_bandwidth','__leaf_bandwidth','__cps','__ip_configuration','__overlay','__vni','__vlan_id','__face',)

  _yang_name = 'virtual_links'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vl_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vl_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='vl_kind', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    self.__cps = YANGDynClass(base=YANGListType("component_index_ref",yc_cps_infra_entity__entity_record_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_infra_entity__entity_record_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)
    self.__overlay = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    self.__vni = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__vlan_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__face = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_record', 'virtual_links']

  def _get_vl_id(self):
    """
    Getter method for vl_id, mapped from YANG variable /entity_record/virtual_links/vl_id (string)
    """
    return self.__vl_id
      
  def _set_vl_id(self, v, load=False):
    """
    Setter method for vl_id, mapped from YANG variable /entity_record/virtual_links/vl_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vl_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vl_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vl_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vl_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vl_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__vl_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vl_id(self):
    self.__vl_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vl_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /entity_record/virtual_links/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /entity_record/virtual_links/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_is_mgmt(self):
    """
    Getter method for is_mgmt, mapped from YANG variable /entity_record/virtual_links/is_mgmt (boolean)
    """
    return self.__is_mgmt
      
  def _set_is_mgmt(self, v, load=False):
    """
    Setter method for is_mgmt, mapped from YANG variable /entity_record/virtual_links/is_mgmt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mgmt() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mgmt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)""",
        })

    self.__is_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mgmt(self):
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)


  def _get_vl_type(self):
    """
    Getter method for vl_type, mapped from YANG variable /entity_record/virtual_links/vl_type (vl_kind)
    """
    return self.__vl_type
      
  def _set_vl_type(self, v, load=False):
    """
    Setter method for vl_type, mapped from YANG variable /entity_record/virtual_links/vl_type (vl_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vl_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vl_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='vl_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vl_type must be of a type compatible with vl_kind""",
          'defined-type': "infra_entity:vl_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='vl_kind', is_config=True)""",
        })

    self.__vl_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vl_type(self):
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='vl_kind', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /entity_record/virtual_links/root_bandwidth (int64)
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /entity_record/virtual_links/root_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /entity_record/virtual_links/leaf_bandwidth (int64)
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /entity_record/virtual_links/leaf_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='int64', is_config=True)


  def _get_cps(self):
    """
    Getter method for cps, mapped from YANG variable /entity_record/virtual_links/cps (list)
    """
    return self.__cps
      
  def _set_cps(self, v, load=False):
    """
    Setter method for cps, mapped from YANG variable /entity_record/virtual_links/cps (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("component_index_ref",yc_cps_infra_entity__entity_record_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cps must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("component_index_ref",yc_cps_infra_entity__entity_record_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)""",
        })

    self.__cps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cps(self):
    self.__cps = YANGDynClass(base=YANGListType("component_index_ref",yc_cps_infra_entity__entity_record_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)


  def _get_ip_configuration(self):
    """
    Getter method for ip_configuration, mapped from YANG variable /entity_record/virtual_links/ip_configuration (container)
    """
    return self.__ip_configuration
      
  def _set_ip_configuration(self, v, load=False):
    """
    Setter method for ip_configuration, mapped from YANG variable /entity_record/virtual_links/ip_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_configuration_infra_entity__entity_record_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_configuration_infra_entity__entity_record_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)""",
        })

    self.__ip_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_configuration(self):
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_infra_entity__entity_record_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)


  def _get_overlay(self):
    """
    Getter method for overlay, mapped from YANG variable /entity_record/virtual_links/overlay (boolean)
    """
    return self.__overlay
      
  def _set_overlay(self, v, load=False):
    """
    Setter method for overlay, mapped from YANG variable /entity_record/virtual_links/overlay (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overlay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overlay() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overlay must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)""",
        })

    self.__overlay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overlay(self):
    self.__overlay = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="overlay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='boolean', is_config=True)


  def _get_vni(self):
    """
    Getter method for vni, mapped from YANG variable /entity_record/virtual_links/vni (string)
    """
    return self.__vni
      
  def _set_vni(self, v, load=False):
    """
    Setter method for vni, mapped from YANG variable /entity_record/virtual_links/vni (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vni is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vni() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vni must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__vni = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vni(self):
    self.__vni = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /entity_record/virtual_links/vlan_id (string)
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /entity_record/virtual_links/vlan_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vlan_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_face(self):
    """
    Getter method for face, mapped from YANG variable /entity_record/virtual_links/face (string)
    """
    return self.__face
      
  def _set_face(self, v, load=False):
    """
    Setter method for face, mapped from YANG variable /entity_record/virtual_links/face (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_face is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_face() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """face must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__face = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_face(self):
    self.__face = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="face", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)

  vl_id = __builtin__.property(_get_vl_id, _set_vl_id)
  uuid = __builtin__.property(_get_uuid, _set_uuid)
  is_mgmt = __builtin__.property(_get_is_mgmt, _set_is_mgmt)
  vl_type = __builtin__.property(_get_vl_type, _set_vl_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  cps = __builtin__.property(_get_cps, _set_cps)
  ip_configuration = __builtin__.property(_get_ip_configuration, _set_ip_configuration)
  overlay = __builtin__.property(_get_overlay, _set_overlay)
  vni = __builtin__.property(_get_vni, _set_vni)
  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)
  face = __builtin__.property(_get_face, _set_face)


  _pyangbind_elements = OrderedDict([('vl_id', vl_id), ('uuid', uuid), ('is_mgmt', is_mgmt), ('vl_type', vl_type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('cps', cps), ('ip_configuration', ip_configuration), ('overlay', overlay), ('vni', vni), ('vlan_id', vlan_id), ('face', face), ])


class yc_entity_record_infra_entity__entity_record(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /entity_record. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__entity_id','__atomic_entities','__virtual_links',)

  _yang_name = 'entity_record'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__entity_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="entity_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    self.__atomic_entities = YANGDynClass(base=YANGListType("uuid",yc_atomic_entities_infra_entity__entity_record_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)
    self.__virtual_links = YANGDynClass(base=YANGListType("uuid",yc_virtual_links_infra_entity__entity_record_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_record']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /entity_record/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /entity_record/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_entity_id(self):
    """
    Getter method for entity_id, mapped from YANG variable /entity_record/entity_id (string)
    """
    return self.__entity_id
      
  def _set_entity_id(self, v, load=False):
    """
    Setter method for entity_id, mapped from YANG variable /entity_record/entity_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entity_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entity_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="entity_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entity_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="entity_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)""",
        })

    self.__entity_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entity_id(self):
    self.__entity_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="entity_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='string', is_config=True)


  def _get_atomic_entities(self):
    """
    Getter method for atomic_entities, mapped from YANG variable /entity_record/atomic_entities (list)
    """
    return self.__atomic_entities
      
  def _set_atomic_entities(self, v, load=False):
    """
    Setter method for atomic_entities, mapped from YANG variable /entity_record/atomic_entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_atomic_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_atomic_entities() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_atomic_entities_infra_entity__entity_record_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """atomic_entities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_atomic_entities_infra_entity__entity_record_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)""",
        })

    self.__atomic_entities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_atomic_entities(self):
    self.__atomic_entities = YANGDynClass(base=YANGListType("uuid",yc_atomic_entities_infra_entity__entity_record_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)


  def _get_virtual_links(self):
    """
    Getter method for virtual_links, mapped from YANG variable /entity_record/virtual_links (list)
    """
    return self.__virtual_links
      
  def _set_virtual_links(self, v, load=False):
    """
    Setter method for virtual_links, mapped from YANG variable /entity_record/virtual_links (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_links() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_virtual_links_infra_entity__entity_record_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_links must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_virtual_links_infra_entity__entity_record_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)""",
        })

    self.__virtual_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_links(self):
    self.__virtual_links = YANGDynClass(base=YANGListType("uuid",yc_virtual_links_infra_entity__entity_record_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  entity_id = __builtin__.property(_get_entity_id, _set_entity_id)
  atomic_entities = __builtin__.property(_get_atomic_entities, _set_atomic_entities)
  virtual_links = __builtin__.property(_get_virtual_links, _set_virtual_links)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('entity_id', entity_id), ('atomic_entities', atomic_entities), ('virtual_links', virtual_links), ])


class infra_entity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infra_entity - based on the path /infra_entity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__entity_record',)

  _yang_name = 'infra_entity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__entity_record = YANGDynClass(base=yc_entity_record_infra_entity__entity_record, is_container='container', yang_name="entity_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_entity_record(self):
    """
    Getter method for entity_record, mapped from YANG variable /entity_record (container)
    """
    return self.__entity_record
      
  def _set_entity_record(self, v, load=False):
    """
    Setter method for entity_record, mapped from YANG variable /entity_record (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entity_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entity_record() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_entity_record_infra_entity__entity_record, is_container='container', yang_name="entity_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entity_record must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_entity_record_infra_entity__entity_record, is_container='container', yang_name="entity_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)""",
        })

    self.__entity_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entity_record(self):
    self.__entity_record = YANGDynClass(base=yc_entity_record_infra_entity__entity_record, is_container='container', yang_name="entity_record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:infra:entity', defining_module='infra_entity', yang_type='container', is_config=True)

  entity_record = __builtin__.property(_get_entity_record, _set_entity_record)


  _pyangbind_elements = OrderedDict([('entity_record', entity_record), ])


