# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_image_user_atomic_entity__ae_descriptor_fdus_image(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/image. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Imange used when instatiating the FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__uri','__checksum','__format',)

  _yang_name = 'image'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'image']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/fdus/image/uuid (string)

    YANG Description: UUID for the image
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/fdus/image/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: UUID for the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/image/name (string)

    YANG Description: Name of the image
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/image/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /ae_descriptor/fdus/image/uri (string)

    YANG Description: The URI for the image
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /ae_descriptor/fdus/image/uri (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: The URI for the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /ae_descriptor/fdus/image/checksum (string)

    YANG Description: SHA1 checksum of the image file
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /ae_descriptor/fdus/image/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: SHA1 checksum of the image file
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_format(self):
    """
    Getter method for format, mapped from YANG variable /ae_descriptor/fdus/image/format (string)

    YANG Description: The format of the image
    """
    return self.__format
      
  def _set_format(self, v, load=False):
    """
    Setter method for format, mapped from YANG variable /ae_descriptor/fdus/image/format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_format() directly.

    YANG Description: The format of the image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_format(self):
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  uri = __builtin__.property(_get_uri, _set_uri)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  format = __builtin__.property(_get_format, _set_format)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('uri', uri), ('checksum', checksum), ('format', format), ])


class yc_command_user_atomic_entity__ae_descriptor_fdus_command(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/command. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Command used for start the BARE FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__binary','__args',)

  _yang_name = 'command'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__binary = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'command']

  def _get_binary(self):
    """
    Getter method for binary, mapped from YANG variable /ae_descriptor/fdus/command/binary (string)

    YANG Description: Path to the binary to be started
    """
    return self.__binary
      
  def _set_binary(self, v, load=False):
    """
    Setter method for binary, mapped from YANG variable /ae_descriptor/fdus/command/binary (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_binary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_binary() directly.

    YANG Description: Path to the binary to be started
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """binary must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__binary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_binary(self):
    self.__binary = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="binary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /ae_descriptor/fdus/command/args (string)

    YANG Description: List of arguments passed to the binary
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /ae_descriptor/fdus/command/args (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: List of arguments passed to the binary
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  binary = __builtin__.property(_get_binary, _set_binary)
  args = __builtin__.property(_get_args, _set_args)


  _pyangbind_elements = OrderedDict([('binary', binary), ('args', args), ])


class yc_computation_requirements_user_atomic_entity__ae_descriptor_fdus_computation_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/computation_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Computation requirement for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__cpu_arch','__cpu_min_freq','__cpu_min_count','__ram_size_mb','__storage_size_gb','__gpu_min_count','__fpga_min_count','__duty_cycle',)

  _yang_name = 'computation_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__cpu_arch = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__cpu_min_freq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__cpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__ram_size_mb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    self.__storage_size_gb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    self.__gpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__fpga_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__duty_cycle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'computation_requirements']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_cpu_arch(self):
    """
    Getter method for cpu_arch, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_arch (string)

    YANG Description: CPU architecture needed by this FDU
    """
    return self.__cpu_arch
      
  def _set_cpu_arch(self, v, load=False):
    """
    Setter method for cpu_arch, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_arch (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_arch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_arch() directly.

    YANG Description: CPU architecture needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_arch must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__cpu_arch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_arch(self):
    self.__cpu_arch = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_cpu_min_freq(self):
    """
    Getter method for cpu_min_freq, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_min_freq (int64)

    YANG Description: Minumum CPU freq needed
    """
    return self.__cpu_min_freq
      
  def _set_cpu_min_freq(self, v, load=False):
    """
    Setter method for cpu_min_freq, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_min_freq (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_min_freq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_min_freq() directly.

    YANG Description: Minumum CPU freq needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_min_freq must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__cpu_min_freq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_min_freq(self):
    self.__cpu_min_freq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_freq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_cpu_min_count(self):
    """
    Getter method for cpu_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_min_count (int64)

    YANG Description: Minumum number of vCPU needed
    """
    return self.__cpu_min_count
      
  def _set_cpu_min_count(self, v, load=False):
    """
    Setter method for cpu_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/cpu_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_min_count() directly.

    YANG Description: Minumum number of vCPU needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__cpu_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_min_count(self):
    self.__cpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="cpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_ram_size_mb(self):
    """
    Getter method for ram_size_mb, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/ram_size_mb (decimal64)

    YANG Description: RAM needed
    """
    return self.__ram_size_mb
      
  def _set_ram_size_mb(self, v, load=False):
    """
    Setter method for ram_size_mb, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/ram_size_mb (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ram_size_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ram_size_mb() directly.

    YANG Description: RAM needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ram_size_mb must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)""",
        })

    self.__ram_size_mb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ram_size_mb(self):
    self.__ram_size_mb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="ram_size_mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)


  def _get_storage_size_gb(self):
    """
    Getter method for storage_size_gb, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/storage_size_gb (decimal64)

    YANG Description: Root disk size needed
    """
    return self.__storage_size_gb
      
  def _set_storage_size_gb(self, v, load=False):
    """
    Setter method for storage_size_gb, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/storage_size_gb (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_size_gb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_size_gb() directly.

    YANG Description: Root disk size needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_size_gb must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)""",
        })

    self.__storage_size_gb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_size_gb(self):
    self.__storage_size_gb = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="storage_size_gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)


  def _get_gpu_min_count(self):
    """
    Getter method for gpu_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/gpu_min_count (int64)

    YANG Description: Minumum number of GPU needed
    """
    return self.__gpu_min_count
      
  def _set_gpu_min_count(self, v, load=False):
    """
    Setter method for gpu_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/gpu_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gpu_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gpu_min_count() directly.

    YANG Description: Minumum number of GPU needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gpu_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__gpu_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gpu_min_count(self):
    self.__gpu_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="gpu_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_fpga_min_count(self):
    """
    Getter method for fpga_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/fpga_min_count (int64)

    YANG Description: Minimum number of FPGA needed
    """
    return self.__fpga_min_count
      
  def _set_fpga_min_count(self, v, load=False):
    """
    Setter method for fpga_min_count, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/fpga_min_count (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fpga_min_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fpga_min_count() directly.

    YANG Description: Minimum number of FPGA needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fpga_min_count must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__fpga_min_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fpga_min_count(self):
    self.__fpga_min_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="fpga_min_count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_duty_cycle(self):
    """
    Getter method for duty_cycle, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/duty_cycle (decimal64)
    """
    return self.__duty_cycle
      
  def _set_duty_cycle(self, v, load=False):
    """
    Setter method for duty_cycle, mapped from YANG variable /ae_descriptor/fdus/computation_requirements/duty_cycle (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duty_cycle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duty_cycle() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duty_cycle must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)""",
        })

    self.__duty_cycle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duty_cycle(self):
    self.__duty_cycle = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="duty_cycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  cpu_arch = __builtin__.property(_get_cpu_arch, _set_cpu_arch)
  cpu_min_freq = __builtin__.property(_get_cpu_min_freq, _set_cpu_min_freq)
  cpu_min_count = __builtin__.property(_get_cpu_min_count, _set_cpu_min_count)
  ram_size_mb = __builtin__.property(_get_ram_size_mb, _set_ram_size_mb)
  storage_size_gb = __builtin__.property(_get_storage_size_gb, _set_storage_size_gb)
  gpu_min_count = __builtin__.property(_get_gpu_min_count, _set_gpu_min_count)
  fpga_min_count = __builtin__.property(_get_fpga_min_count, _set_fpga_min_count)
  duty_cycle = __builtin__.property(_get_duty_cycle, _set_duty_cycle)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('cpu_arch', cpu_arch), ('cpu_min_freq', cpu_min_freq), ('cpu_min_count', cpu_min_count), ('ram_size_mb', ram_size_mb), ('storage_size_gb', storage_size_gb), ('gpu_min_count', gpu_min_count), ('fpga_min_count', fpga_min_count), ('duty_cycle', duty_cycle), ])


class yc_energy_requirements_user_atomic_entity__ae_descriptor_fdus_energy_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/energy_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key',)

  _yang_name = 'energy_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'energy_requirements']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /ae_descriptor/fdus/energy_requirements/key (string)
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /ae_descriptor/fdus/energy_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)


  _pyangbind_elements = OrderedDict([('key', key), ])


class yc_position_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_position(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/geographical_requirements/position. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Postion requirement for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__lat','__lon','__radius',)

  _yang_name = 'position'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__lon = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'geographical_requirements', 'position']

  def _get_lat(self):
    """
    Getter method for lat, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/lat (string)

    YANG Description: Latitude
    """
    return self.__lat
      
  def _set_lat(self, v, load=False):
    """
    Setter method for lat, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/lat (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lat() directly.

    YANG Description: Latitude
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lat must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__lat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lat(self):
    self.__lat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_lon(self):
    """
    Getter method for lon, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/lon (string)

    YANG Description: Longitude
    """
    return self.__lon
      
  def _set_lon(self, v, load=False):
    """
    Setter method for lon, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/lon (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lon() directly.

    YANG Description: Longitude
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lon must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__lon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lon(self):
    self.__lon = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lon", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_radius(self):
    """
    Getter method for radius, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/radius (decimal64)

    YANG Description: Radius in meter
    """
    return self.__radius
      
  def _set_radius(self, v, load=False):
    """
    Setter method for radius, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position/radius (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius() directly.

    YANG Description: Radius in meter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)""",
        })

    self.__radius = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius(self):
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

  lat = __builtin__.property(_get_lat, _set_lat)
  lon = __builtin__.property(_get_lon, _set_lon)
  radius = __builtin__.property(_get_radius, _set_radius)


  _pyangbind_elements = OrderedDict([('lat', lat), ('lon', lon), ('radius', radius), ])


class yc_proximity_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_proximity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/geographical_requirements/proximity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbour','__radius',)

  _yang_name = 'proximity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'geographical_requirements', 'proximity']

  def _get_neighbour(self):
    """
    Getter method for neighbour, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity/neighbour (string)
    """
    return self.__neighbour
      
  def _set_neighbour(self, v, load=False):
    """
    Setter method for neighbour, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity/neighbour (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbour() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbour must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__neighbour = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbour(self):
    self.__neighbour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_radius(self):
    """
    Getter method for radius, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity/radius (decimal64)
    """
    return self.__radius
      
  def _set_radius(self, v, load=False):
    """
    Setter method for radius, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity/radius (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)""",
        })

    self.__radius = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius(self):
    self.__radius = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='decimal64', is_config=True)

  neighbour = __builtin__.property(_get_neighbour, _set_neighbour)
  radius = __builtin__.property(_get_radius, _set_radius)


  _pyangbind_elements = OrderedDict([('neighbour', neighbour), ('radius', radius), ])


class yc_geographical_requirements_user_atomic_entity__ae_descriptor_fdus_geographical_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/geographical_requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__position','__proximity',)

  _yang_name = 'geographical_requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__position = YANGDynClass(base=yc_position_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__proximity = YANGDynClass(base=YANGListType("neighbour",yc_proximity_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'geographical_requirements']

  def _get_position(self):
    """
    Getter method for position, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position (container)

    YANG Description: Postion requirement for this FDU
    """
    return self.__position
      
  def _set_position(self, v, load=False):
    """
    Setter method for position, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/position (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Postion requirement for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_position_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """position must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_position_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_position(self):
    self.__position = YANGDynClass(base=yc_position_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_position, is_container='container', yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_proximity(self):
    """
    Getter method for proximity, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity (list)
    """
    return self.__proximity
      
  def _set_proximity(self, v, load=False):
    """
    Setter method for proximity, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements/proximity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proximity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proximity() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("neighbour",yc_proximity_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proximity must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbour",yc_proximity_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__proximity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proximity(self):
    self.__proximity = YANGDynClass(base=YANGListType("neighbour",yc_proximity_user_atomic_entity__ae_descriptor_fdus_geographical_requirements_proximity, yang_name="proximity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbour', extensions=None), is_container='list', yang_name="proximity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)

  position = __builtin__.property(_get_position, _set_position)
  proximity = __builtin__.property(_get_proximity, _set_proximity)


  _pyangbind_elements = OrderedDict([('position', position), ('proximity', proximity), ])


class yc_configuration_user_atomic_entity__ae_descriptor_fdus_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration script for this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__conf_type','__script','__ssh_keys',)

  _yang_name = 'configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__conf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='conf_types', is_config=True)
    self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__ssh_keys = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'configuration']

  def _get_conf_type(self):
    """
    Getter method for conf_type, mapped from YANG variable /ae_descriptor/fdus/configuration/conf_type (conf_types)

    YANG Description: Configuration script type
    """
    return self.__conf_type
      
  def _set_conf_type(self, v, load=False):
    """
    Setter method for conf_type, mapped from YANG variable /ae_descriptor/fdus/configuration/conf_type (conf_types)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conf_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conf_type() directly.

    YANG Description: Configuration script type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='conf_types', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conf_type must be of a type compatible with conf_types""",
          'defined-type': "user_atomic_entity:conf_types",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='conf_types', is_config=True)""",
        })

    self.__conf_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conf_type(self):
    self.__conf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CLOUD_INIT': {}, 'SCRIPT': {}},), is_leaf=True, yang_name="conf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='conf_types', is_config=True)


  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /ae_descriptor/fdus/configuration/script (string)

    YANG Description: Configuration script
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /ae_descriptor/fdus/configuration/script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.

    YANG Description: Configuration script
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_ssh_keys(self):
    """
    Getter method for ssh_keys, mapped from YANG variable /ae_descriptor/fdus/configuration/ssh_keys (string)
    """
    return self.__ssh_keys
      
  def _set_ssh_keys(self, v, load=False):
    """
    Setter method for ssh_keys, mapped from YANG variable /ae_descriptor/fdus/configuration/ssh_keys (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_keys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_keys() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_keys must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__ssh_keys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_keys(self):
    self.__ssh_keys = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ssh-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  conf_type = __builtin__.property(_get_conf_type, _set_conf_type)
  script = __builtin__.property(_get_script, _set_script)
  ssh_keys = __builtin__.property(_get_ssh_keys, _set_ssh_keys)


  _pyangbind_elements = OrderedDict([('conf_type', conf_type), ('script', script), ('ssh_keys', ssh_keys), ])


class yc_virtual_interface_user_atomic_entity__ae_descriptor_fdus_interfaces_virtual_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/interfaces/virtual_interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__intf_type','__vpci','__bandwidth',)

  _yang_name = 'virtual_interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__intf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vintf_t', is_config=True)
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'interfaces', 'virtual_interface']

  def _get_intf_type(self):
    """
    Getter method for intf_type, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/intf_type (vintf_t)
    """
    return self.__intf_type
      
  def _set_intf_type(self, v, load=False):
    """
    Setter method for intf_type, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/intf_type (vintf_t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vintf_t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_type must be of a type compatible with vintf_t""",
          'defined-type': "user_atomic_entity:vintf_t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vintf_t', is_config=True)""",
        })

    self.__intf_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_type(self):
    self.__intf_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'FOS_MGMT': {}, 'PCI_PASSTHROUGH': {}, 'SR_IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}, 'PHYSICAL': {}, 'BRIDGED': {}},), is_leaf=True, yang_name="intf_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vintf_t', is_config=True)


  def _get_vpci(self):
    """
    Getter method for vpci, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/vpci (string)
    """
    return self.__vpci
      
  def _set_vpci(self, v, load=False):
    """
    Setter method for vpci, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpci() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpci must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__vpci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpci(self):
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/bandwidth (int64)
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface/bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)

  intf_type = __builtin__.property(_get_intf_type, _set_intf_type)
  vpci = __builtin__.property(_get_vpci, _set_vpci)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)


  _pyangbind_elements = OrderedDict([('intf_type', intf_type), ('vpci', vpci), ('bandwidth', bandwidth), ])


class yc_interfaces_user_atomic_entity__ae_descriptor_fdus_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of virtual intefaces used by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__is_mgmt','__if_type','__mac_address','__virtual_interface','__cp_id','__ext_cp_id',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='intf_t', is_config=True)
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_user_atomic_entity__ae_descriptor_fdus_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__ext_cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'interfaces']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/interfaces/name (string)

    YANG Description: Name of the virtual int64eface
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/interfaces/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the virtual int64eface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_is_mgmt(self):
    """
    Getter method for is_mgmt, mapped from YANG variable /ae_descriptor/fdus/interfaces/is_mgmt (boolean)

    YANG Description: True if the int64erface is a management one
    """
    return self.__is_mgmt
      
  def _set_is_mgmt(self, v, load=False):
    """
    Setter method for is_mgmt, mapped from YANG variable /ae_descriptor/fdus/interfaces/is_mgmt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mgmt() directly.

    YANG Description: True if the int64erface is a management one
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mgmt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)""",
        })

    self.__is_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mgmt(self):
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)


  def _get_if_type(self):
    """
    Getter method for if_type, mapped from YANG variable /ae_descriptor/fdus/interfaces/if_type (intf_t)

    YANG Description: Type of the virtualised interface
    """
    return self.__if_type
      
  def _set_if_type(self, v, load=False):
    """
    Setter method for if_type, mapped from YANG variable /ae_descriptor/fdus/interfaces/if_type (intf_t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_type() directly.

    YANG Description: Type of the virtualised interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='intf_t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_type must be of a type compatible with intf_t""",
          'defined-type': "user_atomic_entity:intf_t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='intf_t', is_config=True)""",
        })

    self.__if_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_type(self):
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERNAL': {}, 'EXTERNAL': {}, 'WLAN': {}, 'BLUETOOTH': {}},), is_leaf=True, yang_name="if_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='intf_t', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /ae_descriptor/fdus/interfaces/mac_address (string)

    YANG Description: MAC Address of the int64erface (AA:BB:CC:DD:EE:FF)
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /ae_descriptor/fdus/interfaces/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC Address of the int64erface (AA:BB:CC:DD:EE:FF)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac_address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_virtual_interface(self):
    """
    Getter method for virtual_interface, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface (container)
    """
    return self.__virtual_interface
      
  def _set_virtual_interface(self, v, load=False):
    """
    Setter method for virtual_interface, mapped from YANG variable /ae_descriptor/fdus/interfaces/virtual_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_interface_user_atomic_entity__ae_descriptor_fdus_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_interface_user_atomic_entity__ae_descriptor_fdus_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__virtual_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_interface(self):
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_user_atomic_entity__ae_descriptor_fdus_interfaces_virtual_interface, is_container='container', yang_name="virtual_interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /ae_descriptor/fdus/interfaces/cp_id (string)

    YANG Description: Reference to an internal connection point connected to this interface
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /ae_descriptor/fdus/interfaces/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.

    YANG Description: Reference to an internal connection point connected to this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_ext_cp_id(self):
    """
    Getter method for ext_cp_id, mapped from YANG variable /ae_descriptor/fdus/interfaces/ext_cp_id (string)
    """
    return self.__ext_cp_id
      
  def _set_ext_cp_id(self, v, load=False):
    """
    Setter method for ext_cp_id, mapped from YANG variable /ae_descriptor/fdus/interfaces/ext_cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__ext_cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_cp_id(self):
    self.__ext_cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext_cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  is_mgmt = __builtin__.property(_get_is_mgmt, _set_is_mgmt)
  if_type = __builtin__.property(_get_if_type, _set_if_type)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  virtual_interface = __builtin__.property(_get_virtual_interface, _set_virtual_interface)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)
  ext_cp_id = __builtin__.property(_get_ext_cp_id, _set_ext_cp_id)


  _pyangbind_elements = OrderedDict([('name', name), ('is_mgmt', is_mgmt), ('if_type', if_type), ('mac_address', mac_address), ('virtual_interface', virtual_interface), ('cp_id', cp_id), ('ext_cp_id', ext_cp_id), ])


class yc_storage_user_atomic_entity__ae_descriptor_fdus_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__storage_type','__size','__file_system_protocol','__cp_id',)

  _yang_name = 'storage'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__storage_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='storage_kind', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__file_system_protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'storage']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/fdus/storage/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/fdus/storage/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_storage_type(self):
    """
    Getter method for storage_type, mapped from YANG variable /ae_descriptor/fdus/storage/storage_type (storage_kind)
    """
    return self.__storage_type
      
  def _set_storage_type(self, v, load=False):
    """
    Setter method for storage_type, mapped from YANG variable /ae_descriptor/fdus/storage/storage_type (storage_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='storage_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_type must be of a type compatible with storage_kind""",
          'defined-type': "user_atomic_entity:storage_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='storage_kind', is_config=True)""",
        })

    self.__storage_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_type(self):
    self.__storage_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'FILE': {}, 'OBJECT': {}},), is_leaf=True, yang_name="storage_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='storage_kind', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /ae_descriptor/fdus/storage/size (int64)
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /ae_descriptor/fdus/storage/size (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_file_system_protocol(self):
    """
    Getter method for file_system_protocol, mapped from YANG variable /ae_descriptor/fdus/storage/file_system_protocol (string)
    """
    return self.__file_system_protocol
      
  def _set_file_system_protocol(self, v, load=False):
    """
    Setter method for file_system_protocol, mapped from YANG variable /ae_descriptor/fdus/storage/file_system_protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file_system_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file_system_protocol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file_system_protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__file_system_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file_system_protocol(self):
    self.__file_system_protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file_system_protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /ae_descriptor/fdus/storage/cp_id (string)
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /ae_descriptor/fdus/storage/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  storage_type = __builtin__.property(_get_storage_type, _set_storage_type)
  size = __builtin__.property(_get_size, _set_size)
  file_system_protocol = __builtin__.property(_get_file_system_protocol, _set_file_system_protocol)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)


  _pyangbind_elements = OrderedDict([('id', id), ('storage_type', storage_type), ('size', size), ('file_system_protocol', file_system_protocol), ('cp_id', cp_id), ])


class yc_connection_points_user_atomic_entity__ae_descriptor_fdus_connection_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/connection_points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Internal connection points definited by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__id','__short_name','__cp_type','__port_security_enabled','__vld_ref',)

  _yang_name = 'connection_points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'connection_points']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/fdus/connection_points/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/fdus/connection_points/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/connection_points/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/connection_points/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/fdus/connection_points/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/fdus/connection_points/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /ae_descriptor/fdus/connection_points/short_name (string)
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /ae_descriptor/fdus/connection_points/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_cp_type(self):
    """
    Getter method for cp_type, mapped from YANG variable /ae_descriptor/fdus/connection_points/cp_type (cp_kind)
    """
    return self.__cp_type
      
  def _set_cp_type(self, v, load=False):
    """
    Setter method for cp_type, mapped from YANG variable /ae_descriptor/fdus/connection_points/cp_type (cp_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_type must be of a type compatible with cp_kind""",
          'defined-type': "user_atomic_entity:cp_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)""",
        })

    self.__cp_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_type(self):
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)


  def _get_port_security_enabled(self):
    """
    Getter method for port_security_enabled, mapped from YANG variable /ae_descriptor/fdus/connection_points/port_security_enabled (boolean)
    """
    return self.__port_security_enabled
      
  def _set_port_security_enabled(self, v, load=False):
    """
    Setter method for port_security_enabled, mapped from YANG variable /ae_descriptor/fdus/connection_points/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)""",
        })

    self.__port_security_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security_enabled(self):
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)


  def _get_vld_ref(self):
    """
    Getter method for vld_ref, mapped from YANG variable /ae_descriptor/fdus/connection_points/vld_ref (string)

    YANG Description: Reference to the VL this CP is connected
    """
    return self.__vld_ref
      
  def _set_vld_ref(self, v, load=False):
    """
    Setter method for vld_ref, mapped from YANG variable /ae_descriptor/fdus/connection_points/vld_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld_ref() directly.

    YANG Description: Reference to the VL this CP is connected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__vld_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld_ref(self):
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  id = __builtin__.property(_get_id, _set_id)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  cp_type = __builtin__.property(_get_cp_type, _set_cp_type)
  port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
  vld_ref = __builtin__.property(_get_vld_ref, _set_vld_ref)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('id', id), ('short_name', short_name), ('cp_type', cp_type), ('port_security_enabled', port_security_enabled), ('vld_ref', vld_ref), ])


class yc_io_ports_user_atomic_entity__ae_descriptor_fdus_io_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus/io_ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: I/O ports needed by this FDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__min_io_ports','__io_type',)

  _yang_name = 'io_ports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__min_io_ports = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__io_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='io_kind', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus', 'io_ports']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/io_ports/name (string)

    YANG Description: Name of the IO port
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/io_ports/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IO port
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_min_io_ports(self):
    """
    Getter method for min_io_ports, mapped from YANG variable /ae_descriptor/fdus/io_ports/min_io_ports (int64)

    YANG Description: Minumum number of IO ports needed
    """
    return self.__min_io_ports
      
  def _set_min_io_ports(self, v, load=False):
    """
    Setter method for min_io_ports, mapped from YANG variable /ae_descriptor/fdus/io_ports/min_io_ports (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_io_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_io_ports() directly.

    YANG Description: Minumum number of IO ports needed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_io_ports must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__min_io_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_io_ports(self):
    self.__min_io_ports = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="min_io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_io_type(self):
    """
    Getter method for io_type, mapped from YANG variable /ae_descriptor/fdus/io_ports/io_type (io_kind)

    YANG Description: Type of the IO ports
    """
    return self.__io_type
      
  def _set_io_type(self, v, load=False):
    """
    Setter method for io_type, mapped from YANG variable /ae_descriptor/fdus/io_ports/io_type (io_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_io_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_io_type() directly.

    YANG Description: Type of the IO ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='io_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """io_type must be of a type compatible with io_kind""",
          'defined-type': "user_atomic_entity:io_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='io_kind', is_config=True)""",
        })

    self.__io_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_io_type(self):
    self.__io_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'I2C': {}, 'GPIO': {}, 'CAN': {}, 'BUS': {}, 'COM': {}},), is_leaf=True, yang_name="io_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='io_kind', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  min_io_ports = __builtin__.property(_get_min_io_ports, _set_min_io_ports)
  io_type = __builtin__.property(_get_io_type, _set_io_type)


  _pyangbind_elements = OrderedDict([('name', name), ('min_io_ports', min_io_ports), ('io_type', io_type), ])


class yc_fdus_user_atomic_entity__ae_descriptor_fdus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/fdus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__uuid','__description','__image','__command','__computation_requirements','__energy_requirements','__geographical_requirements','__configuration','__interfaces','__storage','__hypervisor','__migration_kind','__connection_points','__io_ports','__depends_on',)

  _yang_name = 'fdus'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__image = YANGDynClass(base=yc_image_user_atomic_entity__ae_descriptor_fdus_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__command = YANGDynClass(base=yc_command_user_atomic_entity__ae_descriptor_fdus_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__computation_requirements = YANGDynClass(base=yc_computation_requirements_user_atomic_entity__ae_descriptor_fdus_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__energy_requirements = YANGDynClass(base=yc_energy_requirements_user_atomic_entity__ae_descriptor_fdus_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__geographical_requirements = YANGDynClass(base=yc_geographical_requirements_user_atomic_entity__ae_descriptor_fdus_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__configuration = YANGDynClass(base=yc_configuration_user_atomic_entity__ae_descriptor_fdus_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=YANGListType("name",yc_interfaces_user_atomic_entity__ae_descriptor_fdus_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__storage = YANGDynClass(base=YANGListType("id",yc_storage_user_atomic_entity__ae_descriptor_fdus_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__hypervisor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='hv_kind', is_config=True)
    self.__migration_kind = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='migr_kind', is_config=True)
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_fdus_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__io_ports = YANGDynClass(base=YANGListType("name",yc_io_ports_user_atomic_entity__ae_descriptor_fdus_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'fdus']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/fdus/id (string)

    YANG Description: ID of the FDU
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/fdus/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: ID of the FDU
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/fdus/name (string)

    YANG Description: Unique name of the FDU
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/fdus/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name of the FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/fdus/uuid (string)

    YANG Description: This is populated by the Orchestrator
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/fdus/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: This is populated by the Orchestrator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ae_descriptor/fdus/description (string)

    YANG Description: FDU Description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ae_descriptor/fdus/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: FDU Description
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /ae_descriptor/fdus/image (container)

    YANG Description: Imange used when instatiating the FDU
    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /ae_descriptor/fdus/image (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Imange used when instatiating the FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_image_user_atomic_entity__ae_descriptor_fdus_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_image_user_atomic_entity__ae_descriptor_fdus_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=yc_image_user_atomic_entity__ae_descriptor_fdus_image, is_container='container', yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_command(self):
    """
    Getter method for command, mapped from YANG variable /ae_descriptor/fdus/command (container)

    YANG Description: Command used for start the BARE FDU
    """
    return self.__command
      
  def _set_command(self, v, load=False):
    """
    Setter method for command, mapped from YANG variable /ae_descriptor/fdus/command (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_command is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_command() directly.

    YANG Description: Command used for start the BARE FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_command_user_atomic_entity__ae_descriptor_fdus_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """command must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_command_user_atomic_entity__ae_descriptor_fdus_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__command = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_command(self):
    self.__command = YANGDynClass(base=yc_command_user_atomic_entity__ae_descriptor_fdus_command, is_container='container', yang_name="command", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_computation_requirements(self):
    """
    Getter method for computation_requirements, mapped from YANG variable /ae_descriptor/fdus/computation_requirements (container)

    YANG Description: Computation requirement for this FDU
    """
    return self.__computation_requirements
      
  def _set_computation_requirements(self, v, load=False):
    """
    Setter method for computation_requirements, mapped from YANG variable /ae_descriptor/fdus/computation_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_computation_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_computation_requirements() directly.

    YANG Description: Computation requirement for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_computation_requirements_user_atomic_entity__ae_descriptor_fdus_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """computation_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_computation_requirements_user_atomic_entity__ae_descriptor_fdus_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__computation_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_computation_requirements(self):
    self.__computation_requirements = YANGDynClass(base=yc_computation_requirements_user_atomic_entity__ae_descriptor_fdus_computation_requirements, is_container='container', yang_name="computation_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_energy_requirements(self):
    """
    Getter method for energy_requirements, mapped from YANG variable /ae_descriptor/fdus/energy_requirements (container)
    """
    return self.__energy_requirements
      
  def _set_energy_requirements(self, v, load=False):
    """
    Setter method for energy_requirements, mapped from YANG variable /ae_descriptor/fdus/energy_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_energy_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_energy_requirements() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_energy_requirements_user_atomic_entity__ae_descriptor_fdus_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """energy_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_energy_requirements_user_atomic_entity__ae_descriptor_fdus_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__energy_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_energy_requirements(self):
    self.__energy_requirements = YANGDynClass(base=yc_energy_requirements_user_atomic_entity__ae_descriptor_fdus_energy_requirements, is_container='container', yang_name="energy_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_geographical_requirements(self):
    """
    Getter method for geographical_requirements, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements (container)
    """
    return self.__geographical_requirements
      
  def _set_geographical_requirements(self, v, load=False):
    """
    Setter method for geographical_requirements, mapped from YANG variable /ae_descriptor/fdus/geographical_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geographical_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geographical_requirements() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_geographical_requirements_user_atomic_entity__ae_descriptor_fdus_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geographical_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_geographical_requirements_user_atomic_entity__ae_descriptor_fdus_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__geographical_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geographical_requirements(self):
    self.__geographical_requirements = YANGDynClass(base=yc_geographical_requirements_user_atomic_entity__ae_descriptor_fdus_geographical_requirements, is_container='container', yang_name="geographical_requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_configuration(self):
    """
    Getter method for configuration, mapped from YANG variable /ae_descriptor/fdus/configuration (container)

    YANG Description: Configuration script for this FDU
    """
    return self.__configuration
      
  def _set_configuration(self, v, load=False):
    """
    Setter method for configuration, mapped from YANG variable /ae_descriptor/fdus/configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configuration() directly.

    YANG Description: Configuration script for this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_configuration_user_atomic_entity__ae_descriptor_fdus_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_configuration_user_atomic_entity__ae_descriptor_fdus_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configuration(self):
    self.__configuration = YANGDynClass(base=yc_configuration_user_atomic_entity__ae_descriptor_fdus_configuration, is_container='container', yang_name="configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /ae_descriptor/fdus/interfaces (list)

    YANG Description: List of virtual intefaces used by this FDU
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /ae_descriptor/fdus/interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of virtual intefaces used by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interfaces_user_atomic_entity__ae_descriptor_fdus_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interfaces_user_atomic_entity__ae_descriptor_fdus_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=YANGListType("name",yc_interfaces_user_atomic_entity__ae_descriptor_fdus_interfaces, yang_name="interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /ae_descriptor/fdus/storage (list)
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /ae_descriptor/fdus/storage (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_storage_user_atomic_entity__ae_descriptor_fdus_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_storage_user_atomic_entity__ae_descriptor_fdus_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=YANGListType("id",yc_storage_user_atomic_entity__ae_descriptor_fdus_storage, yang_name="storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_hypervisor(self):
    """
    Getter method for hypervisor, mapped from YANG variable /ae_descriptor/fdus/hypervisor (hv_kind)

    YANG Description: Type of hypervisor needed by this FDU
    """
    return self.__hypervisor
      
  def _set_hypervisor(self, v, load=False):
    """
    Setter method for hypervisor, mapped from YANG variable /ae_descriptor/fdus/hypervisor (hv_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hypervisor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hypervisor() directly.

    YANG Description: Type of hypervisor needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='hv_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hypervisor must be of a type compatible with hv_kind""",
          'defined-type': "user_atomic_entity:hv_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='hv_kind', is_config=True)""",
        })

    self.__hypervisor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hypervisor(self):
    self.__hypervisor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BARE': {}, 'LXD': {}, 'KVM': {}, 'KVM_UK': {}, 'XEN': {}, 'XEN_UK': {}, 'MCU': {}, 'DOCKER': {}, 'ROS2': {}},), is_leaf=True, yang_name="hypervisor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='hv_kind', is_config=True)


  def _get_migration_kind(self):
    """
    Getter method for migration_kind, mapped from YANG variable /ae_descriptor/fdus/migration_kind (migr_kind)

    YANG Description: Kind of migration supported by the FDU
    """
    return self.__migration_kind
      
  def _set_migration_kind(self, v, load=False):
    """
    Setter method for migration_kind, mapped from YANG variable /ae_descriptor/fdus/migration_kind (migr_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migration_kind is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migration_kind() directly.

    YANG Description: Kind of migration supported by the FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='migr_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migration_kind must be of a type compatible with migr_kind""",
          'defined-type': "user_atomic_entity:migr_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='migr_kind', is_config=True)""",
        })

    self.__migration_kind = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migration_kind(self):
    self.__migration_kind = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LIVE': {}, 'COLD': {}},), is_leaf=True, yang_name="migration_kind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='migr_kind', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /ae_descriptor/fdus/connection_points (list)

    YANG Description: Internal connection points definited by this FDU
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /ae_descriptor/fdus/connection_points (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: Internal connection points definited by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_fdus_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_fdus_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_fdus_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_io_ports(self):
    """
    Getter method for io_ports, mapped from YANG variable /ae_descriptor/fdus/io_ports (list)

    YANG Description: I/O ports needed by this FDU
    """
    return self.__io_ports
      
  def _set_io_ports(self, v, load=False):
    """
    Setter method for io_ports, mapped from YANG variable /ae_descriptor/fdus/io_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_io_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_io_ports() directly.

    YANG Description: I/O ports needed by this FDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_io_ports_user_atomic_entity__ae_descriptor_fdus_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """io_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_io_ports_user_atomic_entity__ae_descriptor_fdus_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__io_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_io_ports(self):
    self.__io_ports = YANGDynClass(base=YANGListType("name",yc_io_ports_user_atomic_entity__ae_descriptor_fdus_io_ports, yang_name="io_ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="io_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_depends_on(self):
    """
    Getter method for depends_on, mapped from YANG variable /ae_descriptor/fdus/depends_on (string)
    """
    return self.__depends_on
      
  def _set_depends_on(self, v, load=False):
    """
    Setter method for depends_on, mapped from YANG variable /ae_descriptor/fdus/depends_on (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depends_on is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depends_on() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depends_on must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__depends_on = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depends_on(self):
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  uuid = __builtin__.property(_get_uuid, _set_uuid)
  description = __builtin__.property(_get_description, _set_description)
  image = __builtin__.property(_get_image, _set_image)
  command = __builtin__.property(_get_command, _set_command)
  computation_requirements = __builtin__.property(_get_computation_requirements, _set_computation_requirements)
  energy_requirements = __builtin__.property(_get_energy_requirements, _set_energy_requirements)
  geographical_requirements = __builtin__.property(_get_geographical_requirements, _set_geographical_requirements)
  configuration = __builtin__.property(_get_configuration, _set_configuration)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  storage = __builtin__.property(_get_storage, _set_storage)
  hypervisor = __builtin__.property(_get_hypervisor, _set_hypervisor)
  migration_kind = __builtin__.property(_get_migration_kind, _set_migration_kind)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  io_ports = __builtin__.property(_get_io_ports, _set_io_ports)
  depends_on = __builtin__.property(_get_depends_on, _set_depends_on)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('uuid', uuid), ('description', description), ('image', image), ('command', command), ('computation_requirements', computation_requirements), ('energy_requirements', energy_requirements), ('geographical_requirements', geographical_requirements), ('configuration', configuration), ('interfaces', interfaces), ('storage', storage), ('hypervisor', hypervisor), ('migration_kind', migration_kind), ('connection_points', connection_points), ('io_ports', io_ports), ('depends_on', depends_on), ])


class yc_ip_configuration_user_atomic_entity__ae_descriptor_internal_virtual_links_ip_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/internal_virtual_links/ip_configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet','__gateway','__checksum','__dhcp_enable','__dhcp_range','__dns',)

  _yang_name = 'ip_configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='ip_kind', is_config=True)
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'internal_virtual_links', 'ip_configuration']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/ip_version (ip_kind)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/ip_version (ip_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='ip_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with ip_kind""",
          'defined-type': "user_atomic_entity:ip_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='ip_kind', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='ip_kind', is_config=True)


  def _get_subnet(self):
    """
    Getter method for subnet, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/subnet (string)
    """
    return self.__subnet
      
  def _set_subnet(self, v, load=False):
    """
    Setter method for subnet, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/subnet (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__subnet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet(self):
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/gateway (string)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/gateway (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/checksum (string)

    YANG Description: SHA1 checksum of the image file
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: SHA1 checksum of the image file
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_dhcp_enable(self):
    """
    Getter method for dhcp_enable, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dhcp_enable (boolean)
    """
    return self.__dhcp_enable
      
  def _set_dhcp_enable(self, v, load=False):
    """
    Setter method for dhcp_enable, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dhcp_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_enable(self):
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)


  def _get_dhcp_range(self):
    """
    Getter method for dhcp_range, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dhcp_range (string)
    """
    return self.__dhcp_range
      
  def _set_dhcp_range(self, v, load=False):
    """
    Setter method for dhcp_range, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dhcp_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_range() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__dhcp_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_range(self):
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dns (string)
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration/dns (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet = __builtin__.property(_get_subnet, _set_subnet)
  gateway = __builtin__.property(_get_gateway, _set_gateway)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  dhcp_enable = __builtin__.property(_get_dhcp_enable, _set_dhcp_enable)
  dhcp_range = __builtin__.property(_get_dhcp_range, _set_dhcp_range)
  dns = __builtin__.property(_get_dns, _set_dns)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet', subnet), ('gateway', gateway), ('checksum', checksum), ('dhcp_enable', dhcp_enable), ('dhcp_range', dhcp_range), ('dns', dns), ])


class yc_internal_virtual_links_user_atomic_entity__ae_descriptor_internal_virtual_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/internal_virtual_links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__is_mgmt','__short_name','__description','__vl_type','__root_bandwidth','__leaf_bandwidth','__int_cps','__ip_configuration',)

  _yang_name = 'internal_virtual_links'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vl_kind', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    self.__int_cps = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="int_cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_user_atomic_entity__ae_descriptor_internal_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'internal_virtual_links']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/internal_virtual_links/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/internal_virtual_links/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/internal_virtual_links/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/internal_virtual_links/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_is_mgmt(self):
    """
    Getter method for is_mgmt, mapped from YANG variable /ae_descriptor/internal_virtual_links/is_mgmt (boolean)
    """
    return self.__is_mgmt
      
  def _set_is_mgmt(self, v, load=False):
    """
    Setter method for is_mgmt, mapped from YANG variable /ae_descriptor/internal_virtual_links/is_mgmt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mgmt() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mgmt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)""",
        })

    self.__is_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mgmt(self):
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /ae_descriptor/internal_virtual_links/short_name (string)
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /ae_descriptor/internal_virtual_links/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ae_descriptor/internal_virtual_links/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ae_descriptor/internal_virtual_links/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_vl_type(self):
    """
    Getter method for vl_type, mapped from YANG variable /ae_descriptor/internal_virtual_links/vl_type (vl_kind)
    """
    return self.__vl_type
      
  def _set_vl_type(self, v, load=False):
    """
    Setter method for vl_type, mapped from YANG variable /ae_descriptor/internal_virtual_links/vl_type (vl_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vl_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vl_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vl_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vl_type must be of a type compatible with vl_kind""",
          'defined-type': "user_atomic_entity:vl_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vl_kind', is_config=True)""",
        })

    self.__vl_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vl_type(self):
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='vl_kind', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /ae_descriptor/internal_virtual_links/root_bandwidth (int64)
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /ae_descriptor/internal_virtual_links/root_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /ae_descriptor/internal_virtual_links/leaf_bandwidth (int64)
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /ae_descriptor/internal_virtual_links/leaf_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='int64', is_config=True)


  def _get_int_cps(self):
    """
    Getter method for int_cps, mapped from YANG variable /ae_descriptor/internal_virtual_links/int_cps (string)
    """
    return self.__int_cps
      
  def _set_int_cps(self, v, load=False):
    """
    Setter method for int_cps, mapped from YANG variable /ae_descriptor/internal_virtual_links/int_cps (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_cps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_cps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="int_cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """int_cps must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="int_cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__int_cps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_int_cps(self):
    self.__int_cps = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="int_cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_ip_configuration(self):
    """
    Getter method for ip_configuration, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration (container)
    """
    return self.__ip_configuration
      
  def _set_ip_configuration(self, v, load=False):
    """
    Setter method for ip_configuration, mapped from YANG variable /ae_descriptor/internal_virtual_links/ip_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_configuration_user_atomic_entity__ae_descriptor_internal_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_configuration_user_atomic_entity__ae_descriptor_internal_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__ip_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_configuration(self):
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_user_atomic_entity__ae_descriptor_internal_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  is_mgmt = __builtin__.property(_get_is_mgmt, _set_is_mgmt)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  description = __builtin__.property(_get_description, _set_description)
  vl_type = __builtin__.property(_get_vl_type, _set_vl_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  int_cps = __builtin__.property(_get_int_cps, _set_int_cps)
  ip_configuration = __builtin__.property(_get_ip_configuration, _set_ip_configuration)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('is_mgmt', is_mgmt), ('short_name', short_name), ('description', description), ('vl_type', vl_type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('int_cps', int_cps), ('ip_configuration', ip_configuration), ])


class yc_connection_points_user_atomic_entity__ae_descriptor_connection_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor/connection_points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__id','__short_name','__cp_type','__port_security_enabled','__vld_ref',)

  _yang_name = 'connection_points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor', 'connection_points']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/connection_points/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/connection_points/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/connection_points/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/connection_points/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/connection_points/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/connection_points/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /ae_descriptor/connection_points/short_name (string)
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /ae_descriptor/connection_points/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_cp_type(self):
    """
    Getter method for cp_type, mapped from YANG variable /ae_descriptor/connection_points/cp_type (cp_kind)
    """
    return self.__cp_type
      
  def _set_cp_type(self, v, load=False):
    """
    Setter method for cp_type, mapped from YANG variable /ae_descriptor/connection_points/cp_type (cp_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_type must be of a type compatible with cp_kind""",
          'defined-type': "user_atomic_entity:cp_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)""",
        })

    self.__cp_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_type(self):
    self.__cp_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'VPORT': {}},), is_leaf=True, yang_name="cp_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='cp_kind', is_config=True)


  def _get_port_security_enabled(self):
    """
    Getter method for port_security_enabled, mapped from YANG variable /ae_descriptor/connection_points/port_security_enabled (boolean)
    """
    return self.__port_security_enabled
      
  def _set_port_security_enabled(self, v, load=False):
    """
    Setter method for port_security_enabled, mapped from YANG variable /ae_descriptor/connection_points/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)""",
        })

    self.__port_security_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security_enabled(self):
    self.__port_security_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port_security_enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='boolean', is_config=True)


  def _get_vld_ref(self):
    """
    Getter method for vld_ref, mapped from YANG variable /ae_descriptor/connection_points/vld_ref (string)

    YANG Description: Reference to the VL this CP is connected
    """
    return self.__vld_ref
      
  def _set_vld_ref(self, v, load=False):
    """
    Setter method for vld_ref, mapped from YANG variable /ae_descriptor/connection_points/vld_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld_ref() directly.

    YANG Description: Reference to the VL this CP is connected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__vld_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld_ref(self):
    self.__vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  id = __builtin__.property(_get_id, _set_id)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  cp_type = __builtin__.property(_get_cp_type, _set_cp_type)
  port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
  vld_ref = __builtin__.property(_get_vld_ref, _set_vld_ref)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('id', id), ('short_name', short_name), ('cp_type', cp_type), ('port_security_enabled', port_security_enabled), ('vld_ref', vld_ref), ])


class yc_ae_descriptor_user_atomic_entity__ae_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /ae_descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__id','__name','__description','__fdus','__internal_virtual_links','__connection_points','__depends_on',)

  _yang_name = 'ae_descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    self.__fdus = YANGDynClass(base=YANGListType("id",yc_fdus_user_atomic_entity__ae_descriptor_fdus, yang_name="fdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="fdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__internal_virtual_links = YANGDynClass(base=YANGListType("id",yc_internal_virtual_links_user_atomic_entity__ae_descriptor_internal_virtual_links, yang_name="internal_virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal_virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ae_descriptor']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /ae_descriptor/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /ae_descriptor/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ae_descriptor/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ae_descriptor/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ae_descriptor/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ae_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ae_descriptor/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ae_descriptor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)


  def _get_fdus(self):
    """
    Getter method for fdus, mapped from YANG variable /ae_descriptor/fdus (list)
    """
    return self.__fdus
      
  def _set_fdus(self, v, load=False):
    """
    Setter method for fdus, mapped from YANG variable /ae_descriptor/fdus (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fdus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fdus() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_fdus_user_atomic_entity__ae_descriptor_fdus, yang_name="fdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="fdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fdus must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_fdus_user_atomic_entity__ae_descriptor_fdus, yang_name="fdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="fdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__fdus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fdus(self):
    self.__fdus = YANGDynClass(base=YANGListType("id",yc_fdus_user_atomic_entity__ae_descriptor_fdus, yang_name="fdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="fdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_internal_virtual_links(self):
    """
    Getter method for internal_virtual_links, mapped from YANG variable /ae_descriptor/internal_virtual_links (list)
    """
    return self.__internal_virtual_links
      
  def _set_internal_virtual_links(self, v, load=False):
    """
    Setter method for internal_virtual_links, mapped from YANG variable /ae_descriptor/internal_virtual_links (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_virtual_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_virtual_links() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_internal_virtual_links_user_atomic_entity__ae_descriptor_internal_virtual_links, yang_name="internal_virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal_virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_virtual_links must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_internal_virtual_links_user_atomic_entity__ae_descriptor_internal_virtual_links, yang_name="internal_virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal_virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__internal_virtual_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_virtual_links(self):
    self.__internal_virtual_links = YANGDynClass(base=YANGListType("id",yc_internal_virtual_links_user_atomic_entity__ae_descriptor_internal_virtual_links, yang_name="internal_virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal_virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /ae_descriptor/connection_points (list)
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /ae_descriptor/connection_points (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_user_atomic_entity__ae_descriptor_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='list', is_config=True)


  def _get_depends_on(self):
    """
    Getter method for depends_on, mapped from YANG variable /ae_descriptor/depends_on (string)
    """
    return self.__depends_on
      
  def _set_depends_on(self, v, load=False):
    """
    Setter method for depends_on, mapped from YANG variable /ae_descriptor/depends_on (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depends_on is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depends_on() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depends_on must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)""",
        })

    self.__depends_on = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depends_on(self):
    self.__depends_on = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="depends_on", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='string', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  fdus = __builtin__.property(_get_fdus, _set_fdus)
  internal_virtual_links = __builtin__.property(_get_internal_virtual_links, _set_internal_virtual_links)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  depends_on = __builtin__.property(_get_depends_on, _set_depends_on)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('id', id), ('name', name), ('description', description), ('fdus', fdus), ('internal_virtual_links', internal_virtual_links), ('connection_points', connection_points), ('depends_on', depends_on), ])


class user_atomic_entity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_atomic_entity - based on the path /user_atomic_entity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ae_descriptor',)

  _yang_name = 'user_atomic_entity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ae_descriptor = YANGDynClass(base=yc_ae_descriptor_user_atomic_entity__ae_descriptor, is_container='container', yang_name="ae_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ae_descriptor(self):
    """
    Getter method for ae_descriptor, mapped from YANG variable /ae_descriptor (container)
    """
    return self.__ae_descriptor
      
  def _set_ae_descriptor(self, v, load=False):
    """
    Setter method for ae_descriptor, mapped from YANG variable /ae_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ae_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ae_descriptor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ae_descriptor_user_atomic_entity__ae_descriptor, is_container='container', yang_name="ae_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ae_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ae_descriptor_user_atomic_entity__ae_descriptor, is_container='container', yang_name="ae_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)""",
        })

    self.__ae_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ae_descriptor(self):
    self.__ae_descriptor = YANGDynClass(base=yc_ae_descriptor_user_atomic_entity__ae_descriptor, is_container='container', yang_name="ae_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:atomicentity', defining_module='user_atomic_entity', yang_type='container', is_config=True)

  ae_descriptor = __builtin__.property(_get_ae_descriptor, _set_ae_descriptor)


  _pyangbind_elements = OrderedDict([('ae_descriptor', ae_descriptor), ])


