# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_atomic_entities_user_entity__entity_descriptor_atomic_entities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /entity_descriptor/atomic_entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__index',)

  _yang_name = 'atomic_entities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_descriptor', 'atomic_entities']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /entity_descriptor/atomic_entities/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /entity_descriptor/atomic_entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /entity_descriptor/atomic_entities/index (int64)
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /entity_descriptor/atomic_entities/index (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  index = __builtin__.property(_get_index, _set_index)


  _pyangbind_elements = OrderedDict([('id', id), ('index', index), ])


class yc_cps_user_entity__entity_descriptor_virtual_links_cps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /entity_descriptor/virtual_links/cps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component_id_ref','__component_index_ref','__cp_id','__has_floating_ip',)

  _yang_name = 'cps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__component_index_ref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__has_floating_ip = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_descriptor', 'virtual_links', 'cps']

  def _get_component_id_ref(self):
    """
    Getter method for component_id_ref, mapped from YANG variable /entity_descriptor/virtual_links/cps/component_id_ref (string)
    """
    return self.__component_id_ref
      
  def _set_component_id_ref(self, v, load=False):
    """
    Setter method for component_id_ref, mapped from YANG variable /entity_descriptor/virtual_links/cps/component_id_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_id_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_id_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__component_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_id_ref(self):
    self.__component_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component_id_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_component_index_ref(self):
    """
    Getter method for component_index_ref, mapped from YANG variable /entity_descriptor/virtual_links/cps/component_index_ref (int64)
    """
    return self.__component_index_ref
      
  def _set_component_index_ref(self, v, load=False):
    """
    Setter method for component_index_ref, mapped from YANG variable /entity_descriptor/virtual_links/cps/component_index_ref (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_index_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_index_ref must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)""",
        })

    self.__component_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_index_ref(self):
    self.__component_index_ref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="component_index_ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)


  def _get_cp_id(self):
    """
    Getter method for cp_id, mapped from YANG variable /entity_descriptor/virtual_links/cps/cp_id (string)
    """
    return self.__cp_id
      
  def _set_cp_id(self, v, load=False):
    """
    Setter method for cp_id, mapped from YANG variable /entity_descriptor/virtual_links/cps/cp_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__cp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_id(self):
    self.__cp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_has_floating_ip(self):
    """
    Getter method for has_floating_ip, mapped from YANG variable /entity_descriptor/virtual_links/cps/has_floating_ip (boolean)
    """
    return self.__has_floating_ip
      
  def _set_has_floating_ip(self, v, load=False):
    """
    Setter method for has_floating_ip, mapped from YANG variable /entity_descriptor/virtual_links/cps/has_floating_ip (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_has_floating_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_has_floating_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """has_floating_ip must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)""",
        })

    self.__has_floating_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_has_floating_ip(self):
    self.__has_floating_ip = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="has_floating_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)

  component_id_ref = __builtin__.property(_get_component_id_ref, _set_component_id_ref)
  component_index_ref = __builtin__.property(_get_component_index_ref, _set_component_index_ref)
  cp_id = __builtin__.property(_get_cp_id, _set_cp_id)
  has_floating_ip = __builtin__.property(_get_has_floating_ip, _set_has_floating_ip)


  _pyangbind_elements = OrderedDict([('component_id_ref', component_id_ref), ('component_index_ref', component_index_ref), ('cp_id', cp_id), ('has_floating_ip', has_floating_ip), ])


class yc_ip_configuration_user_entity__entity_descriptor_virtual_links_ip_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /entity_descriptor/virtual_links/ip_configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet','__gateway','__checksum','__dhcp_enable','__dhcp_range','__dns',)

  _yang_name = 'ip_configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='ip_kind', is_config=True)
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_descriptor', 'virtual_links', 'ip_configuration']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/ip_version (ip_kind)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/ip_version (ip_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='ip_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with ip_kind""",
          'defined-type': "user_entity:ip_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='ip_kind', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip_version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='ip_kind', is_config=True)


  def _get_subnet(self):
    """
    Getter method for subnet, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/subnet (string)
    """
    return self.__subnet
      
  def _set_subnet(self, v, load=False):
    """
    Setter method for subnet, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/subnet (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__subnet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet(self):
    self.__subnet = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/gateway (string)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/gateway (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/checksum (string)

    YANG Description: SHA1 checksum of the image file
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: SHA1 checksum of the image file
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_dhcp_enable(self):
    """
    Getter method for dhcp_enable, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dhcp_enable (boolean)
    """
    return self.__dhcp_enable
      
  def _set_dhcp_enable(self, v, load=False):
    """
    Setter method for dhcp_enable, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dhcp_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_enable(self):
    self.__dhcp_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)


  def _get_dhcp_range(self):
    """
    Getter method for dhcp_range, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dhcp_range (string)
    """
    return self.__dhcp_range
      
  def _set_dhcp_range(self, v, load=False):
    """
    Setter method for dhcp_range, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dhcp_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_range() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__dhcp_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_range(self):
    self.__dhcp_range = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dhcp_range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dns (string)
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration/dns (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet = __builtin__.property(_get_subnet, _set_subnet)
  gateway = __builtin__.property(_get_gateway, _set_gateway)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  dhcp_enable = __builtin__.property(_get_dhcp_enable, _set_dhcp_enable)
  dhcp_range = __builtin__.property(_get_dhcp_range, _set_dhcp_range)
  dns = __builtin__.property(_get_dns, _set_dns)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet', subnet), ('gateway', gateway), ('checksum', checksum), ('dhcp_enable', dhcp_enable), ('dhcp_range', dhcp_range), ('dns', dns), ])


class yc_virtual_links_user_entity__entity_descriptor_virtual_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /entity_descriptor/virtual_links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__is_mgmt','__short_name','__description','__vl_type','__root_bandwidth','__leaf_bandwidth','__cps','__ip_configuration',)

  _yang_name = 'virtual_links'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='vl_kind', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    self.__cps = YANGDynClass(base=YANGListType("component_index_ref",yc_cps_user_entity__entity_descriptor_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_user_entity__entity_descriptor_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_descriptor', 'virtual_links']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /entity_descriptor/virtual_links/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /entity_descriptor/virtual_links/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /entity_descriptor/virtual_links/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /entity_descriptor/virtual_links/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_is_mgmt(self):
    """
    Getter method for is_mgmt, mapped from YANG variable /entity_descriptor/virtual_links/is_mgmt (boolean)
    """
    return self.__is_mgmt
      
  def _set_is_mgmt(self, v, load=False):
    """
    Setter method for is_mgmt, mapped from YANG variable /entity_descriptor/virtual_links/is_mgmt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_mgmt() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_mgmt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)""",
        })

    self.__is_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_mgmt(self):
    self.__is_mgmt = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is_mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='boolean', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /entity_descriptor/virtual_links/short_name (string)
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /entity_descriptor/virtual_links/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /entity_descriptor/virtual_links/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /entity_descriptor/virtual_links/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_vl_type(self):
    """
    Getter method for vl_type, mapped from YANG variable /entity_descriptor/virtual_links/vl_type (vl_kind)
    """
    return self.__vl_type
      
  def _set_vl_type(self, v, load=False):
    """
    Setter method for vl_type, mapped from YANG variable /entity_descriptor/virtual_links/vl_type (vl_kind)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vl_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vl_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='vl_kind', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vl_type must be of a type compatible with vl_kind""",
          'defined-type': "user_entity:vl_kind",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='vl_kind', is_config=True)""",
        })

    self.__vl_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vl_type(self):
    self.__vl_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ELINE': {}, 'ELAN': {}},), is_leaf=True, yang_name="vl_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='vl_kind', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /entity_descriptor/virtual_links/root_bandwidth (int64)
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /entity_descriptor/virtual_links/root_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="root_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /entity_descriptor/virtual_links/leaf_bandwidth (int64)
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /entity_descriptor/virtual_links/leaf_bandwidth (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="leaf_bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='int64', is_config=True)


  def _get_cps(self):
    """
    Getter method for cps, mapped from YANG variable /entity_descriptor/virtual_links/cps (list)
    """
    return self.__cps
      
  def _set_cps(self, v, load=False):
    """
    Setter method for cps, mapped from YANG variable /entity_descriptor/virtual_links/cps (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("component_index_ref",yc_cps_user_entity__entity_descriptor_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cps must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("component_index_ref",yc_cps_user_entity__entity_descriptor_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)""",
        })

    self.__cps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cps(self):
    self.__cps = YANGDynClass(base=YANGListType("component_index_ref",yc_cps_user_entity__entity_descriptor_virtual_links_cps, yang_name="cps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='component_index_ref', extensions=None), is_container='list', yang_name="cps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)


  def _get_ip_configuration(self):
    """
    Getter method for ip_configuration, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration (container)
    """
    return self.__ip_configuration
      
  def _set_ip_configuration(self, v, load=False):
    """
    Setter method for ip_configuration, mapped from YANG variable /entity_descriptor/virtual_links/ip_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_configuration_user_entity__entity_descriptor_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_configuration_user_entity__entity_descriptor_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)""",
        })

    self.__ip_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_configuration(self):
    self.__ip_configuration = YANGDynClass(base=yc_ip_configuration_user_entity__entity_descriptor_virtual_links_ip_configuration, is_container='container', yang_name="ip_configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  is_mgmt = __builtin__.property(_get_is_mgmt, _set_is_mgmt)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  description = __builtin__.property(_get_description, _set_description)
  vl_type = __builtin__.property(_get_vl_type, _set_vl_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  cps = __builtin__.property(_get_cps, _set_cps)
  ip_configuration = __builtin__.property(_get_ip_configuration, _set_ip_configuration)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('is_mgmt', is_mgmt), ('short_name', short_name), ('description', description), ('vl_type', vl_type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('cps', cps), ('ip_configuration', ip_configuration), ])


class yc_entity_descriptor_user_entity__entity_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /entity_descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__id','__name','__description','__version','__atomic_entities','__virtual_links',)

  _yang_name = 'entity_descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    self.__atomic_entities = YANGDynClass(base=YANGListType("index",yc_atomic_entities_user_entity__entity_descriptor_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)
    self.__virtual_links = YANGDynClass(base=YANGListType("id",yc_virtual_links_user_entity__entity_descriptor_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['entity_descriptor']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /entity_descriptor/uuid (string)
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /entity_descriptor/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /entity_descriptor/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /entity_descriptor/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /entity_descriptor/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /entity_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /entity_descriptor/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /entity_descriptor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /entity_descriptor/version (string)
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /entity_descriptor/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='string', is_config=True)


  def _get_atomic_entities(self):
    """
    Getter method for atomic_entities, mapped from YANG variable /entity_descriptor/atomic_entities (list)
    """
    return self.__atomic_entities
      
  def _set_atomic_entities(self, v, load=False):
    """
    Setter method for atomic_entities, mapped from YANG variable /entity_descriptor/atomic_entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_atomic_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_atomic_entities() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_atomic_entities_user_entity__entity_descriptor_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """atomic_entities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_atomic_entities_user_entity__entity_descriptor_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)""",
        })

    self.__atomic_entities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_atomic_entities(self):
    self.__atomic_entities = YANGDynClass(base=YANGListType("index",yc_atomic_entities_user_entity__entity_descriptor_atomic_entities, yang_name="atomic_entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="atomic_entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)


  def _get_virtual_links(self):
    """
    Getter method for virtual_links, mapped from YANG variable /entity_descriptor/virtual_links (list)
    """
    return self.__virtual_links
      
  def _set_virtual_links(self, v, load=False):
    """
    Setter method for virtual_links, mapped from YANG variable /entity_descriptor/virtual_links (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_links() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtual_links_user_entity__entity_descriptor_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_links must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_links_user_entity__entity_descriptor_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)""",
        })

    self.__virtual_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_links(self):
    self.__virtual_links = YANGDynClass(base=YANGListType("id",yc_virtual_links_user_entity__entity_descriptor_virtual_links, yang_name="virtual_links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual_links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  atomic_entities = __builtin__.property(_get_atomic_entities, _set_atomic_entities)
  virtual_links = __builtin__.property(_get_virtual_links, _set_virtual_links)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('id', id), ('name', name), ('description', description), ('version', version), ('atomic_entities', atomic_entities), ('virtual_links', virtual_links), ])


class user_entity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module user_entity - based on the path /user_entity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__entity_descriptor',)

  _yang_name = 'user_entity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__entity_descriptor = YANGDynClass(base=yc_entity_descriptor_user_entity__entity_descriptor, is_container='container', yang_name="entity_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_entity_descriptor(self):
    """
    Getter method for entity_descriptor, mapped from YANG variable /entity_descriptor (container)
    """
    return self.__entity_descriptor
      
  def _set_entity_descriptor(self, v, load=False):
    """
    Setter method for entity_descriptor, mapped from YANG variable /entity_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entity_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entity_descriptor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_entity_descriptor_user_entity__entity_descriptor, is_container='container', yang_name="entity_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entity_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_entity_descriptor_user_entity__entity_descriptor, is_container='container', yang_name="entity_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)""",
        })

    self.__entity_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entity_descriptor(self):
    self.__entity_descriptor = YANGDynClass(base=yc_entity_descriptor_user_entity__entity_descriptor, is_container='container', yang_name="entity_descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:fog05:im:user:entity', defining_module='user_entity', yang_type='container', is_config=True)

  entity_descriptor = __builtin__.property(_get_entity_descriptor, _set_entity_descriptor)


  _pyangbind_elements = OrderedDict([('entity_descriptor', entity_descriptor), ])


