#!/bin/bash

#############################################################

usage()
{
cat << EOF >&2
Usage: `basename $0` [-h] [-s] [-l QUERY_LIMIT] [-t {async,sync}] in_dir cone_file out_dir
EOF
}

#############################################################

help()
{
usage
cat << EOF >&2

Measure performance on all the specified services in the in_dir directory tree.


Positional arguments:
    in_dir             Generate random cones
    cone_file          Replay queries from a previous result file.
    out_dir            Query a list of services

Optional arguments:
  -h        Show this help message and exit
  -s        Save the query result data files. Without this
            argument, the query result file will be deleted after
            metadata is gathered for the query.
  -l QUERY_LIMIT
            Maximum number of cones to query (default=no limit)
  -t {async,sync}
            How to run TAP queries (default=async)

EXAMPLES:
  `basename $0` input input/cones.py output
  `basename $0` -l 100 input input/cones.py output
  `basename $0` -t sync input input/cones.py output

EOF
}

#############################################################

parseOptions()
{
    # Defaults
    SAVE_RESULTS=0
    LIMIT=0
    TAP_MODE="async"

    # Read command line args
    while getopts ":hsl:t:" OPTION
    do
        case $OPTION in
            h)
              help
              exit 0
              ;;
            s)
              SAVE_RESULTS=1
              ;;
            l)
              LIMIT=$OPTARG
              if ! [[ "$LIMIT" =~ ^[0-9]+$ ]] ; then
                 echo "-l (query limit) must be a non-negative integer." 1>&2
                 exit 1
              fi
              ;;
            t)
              TAP_MODE=$OPTARG
              if [[ "$TAP_MODE" != "sync" && "$TAP_MODE" != "async" ]] ; then
                 echo "-t (tap mode) value must be sync or async" 1>&2
                 exit 1
              fi
              ;;
            \?)
              echo "Invalid Option: -$OPTARG" 1>&2
              usage
              exit 1
              ;;
        esac
    done
}

#############################################################

parseArgs()
{
    ARGS=("$@")

    numArgs=${#ARGS[@]}

    if (( $numArgs != 3 )) ; then
        echo "Command must have 3 arguments" >&2
        usage
        exit 1
    else
        IN_DIR="${ARGS[0]}"
        CONE_FILE="${ARGS[1]}"
        OUT_DIR="${ARGS[2]}"
    fi

}

#############################################################

dumpInfo()
{

    numArgs=${#ARGS[@]}

    echo total number of args = ${#ALL_ARGS[@]}
    echo number of trimmed args = $numArgs

    # Dump command info
    echo SCRIPT_DIR = $SCRIPT_DIR
    echo IN_DIR = $IN_DIR
    echo CONE_FILE = $CONE_FILE
    echo OUT_DIR = $OUT_DIR
    echo SAVE_RESULTS = $SAVE_RESULTS
    echo LIMIT = $LIMIT
    echo TAP_MODE = $TAP_MODE

}

#############################################################

# Main Program...

# Global variables
ALL_ARGS=("$@")
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Parse the options and remove them from the command args.
parseOptions $@
shift "$(($OPTIND -1))"

# Parse the remaining arguments
parseArgs $@

mkdir -p "${OUT_DIR}"

shopt -s nullglob  # With no matches, don't enter loop
for in_sub_dir in ${IN_DIR}/*; do
    if [ -d "${in_sub_dir}" ]; then
      SUB_DIR=`basename ${in_sub_dir}`
      PYTHONFAULTHANDLER=true servicemon_run_helper \
         ${SAVE_RESULTS} \
         ${LIMIT} \
         ${TAP_MODE} \
         ${IN_DIR} \
         ${CONE_FILE} \
         ${OUT_DIR} \
         ${SUB_DIR} \
         >> "${OUT_DIR}"/"${SUB_DIR}"-`date "+%Y-%m-%d-%H-%M"`_comlog.txt 2>&1 &
    fi
done






